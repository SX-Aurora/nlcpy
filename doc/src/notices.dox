#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

##
# @if(lang_ja)
# @else
# @page notices Notices and Restrictions
# This page describes notices and restrictions which are common to NLCPy functions.
# # Notices #
# <ol>
# <li> To use NLCPy in your Python scripts, the package @c nlcpy must be imported.
#      For more details, see @ref basic_usage.
#      @n
# </li>
# <li> To reduce overhead between Vector Host and Vector Engine, NLCPy adopts the lazy evaluation,
#      which means that values are not calculated until they are required.
#      So the position of warnings where your Python script raised may not be accurate.
#      For details, see @ref lazy.
#      <ul>
#      <li> Example:
#      @code
#      # sample.py
#      import nlcpy as vp
#      a = vp.divide(1, 0) # divide by zero warning
#      b = a + 1
#      print(b)
#      @endcode
#      </li>
#      <li> Results:
#      @verbatim
#      $ python sample.py
#      sample.py:5: RuntimeWarning: divide by zero encountered in nlcpy.core.core
#        print(b)
#      inf
#      @endverbatim
#      </li>
#      </ul>
#      @n
# </li>
# <li> NLCPy API is based on NumPy one. However, there are some differences due to performance reasons.
#      For example, when NumPy function returns a scalar value, NLCPy function returns
#      it as a 0-dimension array.
#      @code
#      >>> import numpy, nlcpy
#      >>> numpy.add(1,2)         # returns a scalar
#      3
#      >>> nlcpy.add(1,2)         # returns an array
#      array(3)
#      >>> nlcpy.add(1,2).ndim    # print the dimention of nlcpy.add(1.2)
#      0
#      @endcode
#      @n
# </li>
# <li> Vector Host (x86/Linux) supports denormal numbers, whereas Vector Engine does NOT support
#      it. So, if denormal numbers are caluculated in NLCPy functions, they are rounded to zero.
#      @code
#      >>> import numpy, nlcpy
#      >>> x=numpy.array([-1.e-310, +1.e-310])    # denormal numbers in IEEE754 double precision format.
#      >>> x
#      array([-1.e-310,  1.e-310])
#      >>>
#      >>> numpy.add(x,0)
#      array([-1.e-310,  1.e-310])                # works on Vector Host
#      >>>
#      >>> nlcpy.add(x,0)                         # works on Vector Engine
#      array([0., 0.])
#      @endcode
#      @n
# </li>
# </ol>
# # Restrictions #
# Here is a list of restrictions which are common to NLCPy functions.
# Besides these restrictions, there are some individual restrictions.
# Please see also the item of "Restrictions" in the detailed description of each function.
# <ol>
# <li> Data type, which is called "dtype", can be specified for NLCPy functions like NumPy ones.
#      However, the current version of NLCPy supports only the following dtypes:
#      <table>
#      <tr><th>data-type</th><th>dtype</th><th>character code</th></tr>
#      <tr><td>bool</td><td>'bool' </td><td>'?'</td></tr>
#      <tr><td>32-bit signed integer</td><td>'int32', 'i4' </td><td>'i'</td></tr>
#      <tr><td>64-bit signed integer</td><td>'int64', 'i8', int</td><td>'l', 'q'</td></tr>
#      <tr><td>32-bit unsigned integer</td><td>'uint32', 'u4' </td><td>'I'</td></tr>
#      <tr><td>64-bit unsigned integer</td><td>'uint64', 'u8', uint</td><td>'L', 'Q'</td></tr>
#      <tr><td>32-bit floating-point real</td><td>'float32', 'f4'</td><td>'f'</td></tr>
#      <tr><td>64-bit floating-point real</td><td>'float64', 'f8', 'float'</td><td>'d'</td></tr>
#      <tr><td>32-bit floating-point complex</td><td>'complex64', 'c8'</td><td>'F'</td></tr>
#      <tr><td>64-bit floating-point complex</td><td>'complex128', 'c16', 'complex'</td><td>'D'</td></tr>
#      </table>
#      Each dtype has character codes that identify it.
#      In NLCPy, the character code 'q' and 'Q' are internally converted to 'l' and 'L', respectively.
#      The dtypes and character codes other than described above are not supported yet. 
#      In addition, the current version does not support a structured data type, which contains above dtypes.@n@n
#      Please note that there are functions which can not even support above dtypes.
#      For example, the complex version of @ref function_base::mean "nlcpy.mean" does not support.
#      @code
#      >>> import nlcpy
#      >>> nlcpy.mean(vp.array([1,2,3],dtype='complex64'))
#      NotImplementedError: dtype=complex64 not supported
#      @endcode
#      @n
# </li>
# <li> If the unsupported dtype appears in the parameter list or the return type for NLCPy function, @em TypeError occurs.
#      In case a NumPy function treats float16 type internally, 
#      the corresponding NLCPy function treats it as float32.
#      Similarly, int8, int16, uint8, or uint16 is treated as int32 or uint32
#      during calculations.
#      In such case the return value of NLCPy differs from that of NumPy.@n
#      @code
#      >>> import numpy
#      >>>
#      >>> # numpy.divide.accumulate() treats 1e-8 as float16.
#      >>> numpy.divide.accumulate([1e-8], dtype='bool')   
#      array([0.], dtype=float16)
#      >>>
#      >>> # 1e-8 is internally rounded to zero in float16 type,
#      >>> # so the boolean result becomes False.
#      >>> numpy.divide.accumulate([1e-8], dtype='bool', out=np.array([True]))
#      array([False])
#      >>>
#      @endcode@n
#      @code
#      >>> import nlcpy
#      >>>
#      >>> # NLCPy does not support float16, so TypeError occors.
#      >>> nlcpy.divide.accumulate([1e-8], dtype='bool')
#      TypeError: not support for float16.
#      >>>
#      >>> # 1e-8 is treated as float32, so the boolean result becomes True.
#      >>> nlcpy.divide.accumulate([1e-8], dtype='bool', out=vp.array([True]))
#      array([ True])
#      @endcode
#      @n
# </li>
# </ol>
# @endif

