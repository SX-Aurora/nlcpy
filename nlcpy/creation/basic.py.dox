#
# * The source code in this file is developed independently by NEC Corporation.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
import nlcpy
import numpy
import warnings

from nlcpy.request import request


# ----------------------------------------------------------------------------
# create ones and zeros arrays
# see: https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html
# ----------------------------------------------------------------------------
##
# @name Ones and zeros
# @{
#
## @fn empty(shape, dtype=float, order='C')
# @rename basic.empty empty nlcpy.empty
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a new array of given shape and type, without initializing entries.
# 
# @details 
# @param shape : <em>int or sequence of int</em> @n
#   Shape of the empty array, e.g., (2, 3) or 2.
# 
# @param dtype : <em>dtype, @b optional</em> @n
#   Desired output dtype for the array, e.g, @b nlcpy.int64.
#   Default is @b nlcpy.float64.
# 
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Whether to store multi-dimensional data in row-major (C-style)
#   or column-major (Fortran-style) order in memory.
# 
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of uninitialized (arbitrary) data of the given shape, dtype,
#   and order.
#
# @sa
#   @li @ref empty_like : Returns a new array with the same %shape and type
#                         as a given array.
#   @li @ref ones : Returns a new array of given %shape and type, filled with %ones.
#   @li @ref zeros : Returns a new array of given %shape and type, filled with %zeros.
#   @li @ref full : Returns a new array of given %shape and type,
#                   filled with fill_value.
#
# @note
#   @ref empty, unlike @ref zeros, does not set the array values to zero,
#   and may therefore be marginally faster. On the other hand, it requires 
#   the user to manually set all the values in the array, and should be used
#   with caution.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.empty([2, 2])
# array([[ 0.,   0.],
#        [ 0.,   0.]])         # They are not always zero. (uninitialized)
# @endcode @n
# @code
# >>> vp.empty([2, 2], dtype=int)
# array([[ 0,   0],
#        [ 0,   0]])         # They are not always zero. (uninitialized)
# @endcode
# 
# @endpydoc
# @endif
def empty(shape, dtype=float, order='C'):
    return nlcpy.ndarray(shape=shape, dtype=dtype, order=order)


# ----------------------------------------------------------------------------
# not implemented routines
# default order value is temporarily set to 'C'.
# default subok value is temporarily set to False.
# ----------------------------------------------------------------------------

## @fn empty_like(prototype, dtype=None, order='K', subok=False, shape=None)
# @rename basic.empty_like empty_like nlcpy.empty_like
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a new array with the same shape and type as a given array.
#
# @details
# @param prototype : <em>array_like</em> @n
#   The shape and dtype of @em prototype define these same attributes
#   of the returned array.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   Overrides the data type of the result.
#
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Overrides the memory layout of the result. 'C' means C-order, 'F' means
#   F-order, 'A' means 'F' if <span class="pre">prototype</span> is Fortran
#   contiguous, 'C' otherwise. 'K' means match the layout of
#   <span class="pre">prototype</span> as closely as possible.
#
# @param subok : <em>bool, @b optional</em> @n
#   Not implemented.
#
# @param shape : <em>int or sequence of ints, @b optional</em> @n
#   Overrides the shape of the result. If order='K' and the number of
#   dimensions is unchanged, will try to keep order, otherwise,
#   order='C' is implied.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of uninitialized (arbitrary) data with the same shape
#   and type as @em prototype.
#
# @sa
#   @li @ref ones_like : Returns an array of %ones with the same %shape and type
#                         as a given array.
#   @li @ref zeros_like : Returns an array of %zeros with the same %shape
#                         and type as a given array.
#   @li @ref full_like : Returns a %full array with the same %shape
#                        and type as a given array.
#   @li @ref empty : Returns a new array of given %shape and type,
#                    without initializing entries.
#
# @note
#   This function does not initialize the returned array; to do that use 
#   @ref zeros_like or @ref ones_like instead. It may be marginally faster than
#   the functions that do set the array values.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = ([1,2,3], [4,5,6])                         # a is array-like
# >>> vp.empty_like(a)
# array([[-1073741821, -1073741821,           3],    # uninitialized
#        [          0,           0, -1073741821]])
# >>> a = vp.array([[1., 2., 3.],[4.,5.,6.]])
# >>> vp.empty_like(a)
# array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
#        [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
# @endcode
#
# @endpydoc
# @endif
def empty_like(prototype, dtype=None, order='K', subok=False, shape=None):
    if subok is not False:
        raise NotImplementedError('subok in empty_like is not implemented yet.')

    prototype = nlcpy.asanyarray(prototype)

    if shape is None:
        shape = prototype.shape
    if dtype is None:
        dtype = prototype.dtype
    if order is None or order in 'kKaA':
        if prototype._f_contiguous and not prototype._c_contiguous:
            order = 'F'
        else:
            order = 'C'

    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in empty_like is not implemented yet.')

    out = nlcpy.ndarray(shape=shape, dtype=dtype, order=order)
    return out


## @fn eye(N, M=None, k=0, dtype=float, order='C')
# @rename basic.eye eye nlcpy.eye
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a 2-D array with ones on the diagonal and zeros elsewhere.
#
# @details
# @param N : <em>int</em> @n
#   Number of rows in the output.
#
# @param M : <em>int, @b optional</em> @n
#   Number of columns in the output. If None, defaults to @em N.
#
# @param k : <em>int, @b optional</em> @n
#   Index of the diagonal: 0 (the default) refers to the main diagonal,
#   a positive value refers to an upper diagonal, and a negative value
#   to a lower diagonal.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   Data-type of the returned array.
#
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Whether the output should be stored in row-major (C-style) or column-major
#   (Fortran-style) order in memory.
#
# @retval I : <em>@ref n-dimensional_array "ndarray"</em> @n
#   An array where all elements are equal to zero, except for the <em>k</em>-th
#   diagonal, whose values are equal to one.
#
# @sa
#   @li @ref identity : Returns the %identity array.
#   @li @ref matrices.diag "diag" : Extracts a diagonal or construct a diagonal array.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.eye(2, dtype=int)
# array([[1, 0],
#        [0, 1]])
# >>> vp.eye(3, k=1)
# array([[0.,  1.,  0.],
#        [0.,  0.,  1.],
#        [0.,  0.,  0.]])
# @endcode
#
# @endpydoc
# @endif
def eye(N, M=None, k=0, dtype=float, order='C'):
    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in eye is not implemented yet.')
    if M is None:
        M = N

    out = nlcpy.ndarray(shape=(N, M), dtype=dtype, order=order)

    if order == 'F':
        N, M = M, N

    request._push_request(
        "nlcpy_eye",
        "creation_op",
        (out, int(N), int(M), int(k)),)

    return out


## @fn identity(n, dtype=None)
# @rename basic.identity identity nlcpy.identity
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns the identity array.@n
#        The identity array is a square array with ones on the main diagonal.
#
# @details
# @param n : <em>int</em> @n
#   Number of rows (and columns) in @em n x @em n output.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   Data-type of the output. Defaults to <span class="pre">nlcpy.float64</span>.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   @em n x @em n array with its main diagonal set to 1, and all other elements 0.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.identity(3)
# array([[1.,  0.,  0.],
#        [0.,  1.,  0.],
#        [0.,  0.,  1.]])
# @endcode
#
# @endpydoc
# @endif
def identity(n, dtype=None):
    return eye(N=n, dtype=dtype)


## @fn ones(shape, dtype=None, order='C')
# @rename basic.ones ones nlcpy.ones
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a new array of given shape and type, filled with ones.
#
# @details
# @param shape : <em>int or sequence of ints</em> @n
#   Shape of the new array, e.g., <span class="pre">(2, 3)</span> or <span class="pre">2</span>.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   The desired dtype for the array, e.g, @b nlcpy.int64.
#   Default is @b nlcpy.float64.
#
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Whether to store multi-dimensional data in row-major (C-style)
#   or column-major (Fortran-style) order in memory.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of ones with the given shape, dtype, and order.
#
# @sa
#   @li @ref ones_like : Returns an array of %ones with the same %shape and type
#                        as a given array.
#   @li @ref empty : Returns a new array of given %shape and type,
#                        without initializing entries.
#   @li @ref zeros : Returns a new array of given %shape and type, filled with %zeros.
#   @li @ref full : Returns a new array of given %shape and type,
#                   filled with fill_value.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.ones(5)
# array([1., 1., 1., 1., 1.])
# @endcode @n
# @code
# >>> vp.ones((5,), dtype=int)
# array([1, 1, 1, 1, 1])
# @endcode @n
# @code
# >>> vp.ones((2, 1))
# array([[1.],
#        [1.]])
# @endcode @n
# @code
# >>> s = (2,2)
# >>> vp.ones(s)
# array([[1.,  1.],
#        [1.,  1.]])
# @endcode
#
# @endpydoc
# @endif
def ones(shape, dtype=None, order='C'):
    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in ones is not implemented yet.')
    out = nlcpy.ndarray(shape=shape, dtype=dtype, order=order)
    out.fill(1)
    return out


## @fn ones_like(a, dtype=None, order='K', subok=False, shape=None)
# @rename basic.ones_like ones_like nlcpy.ones_like
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns an array of ones with the same shape and type as a given array.
#
# @details
# @param a : <em>array_like</em> @n
#   The shape and dtype of @em a define these same attributes of
#   the returned array.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   Overrides the data type of the result.
#
# @param order : <em>{'C', 'F', 'A', or 'K'}, @b optional</em> @n
#   Overrides the memory layout of the result. 'C' means C-order,
#   'F' means F-order, 'A' means 'F' if @em a is Fortran contiguous,
#   'C' otherwise. 'K' means match the layout of @em a as closely as possible.
#
# @param subok : <em>bool, @b optional</em> @n
#   Not implemented.
#
# @param shape : <em>int or sequence of ints, @b optional</em> @n
#   Overrides the shape of the result. If order='K' and the number
#   of dimensions is unchanged, will try to keep order, otherwise,
#   order='C' is implied.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of ones with the same shape and type as @em a.
#
# @sa
#   @li @ref empty_like : Returns a new array with the same %shape and type
#                         as a given array.
#   @li @ref zeros_like : Returns an array of %zeros with the same %shape and type
#                         as a given array.
#   @li @ref full_like : Returns a %full array with the same %shape and type
#                        as a given array.
#   @li @ref ones : Returns a new array of given %shape and type, filled with %ones.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> x = vp.arange(6)
# >>> x = x.reshape((2, 3))
# >>> x
# array([[0, 1, 2],
#        [3, 4, 5]])
# >>> vp.ones_like(x)
# array([[1, 1, 1],
#        [1, 1, 1]])
# @endcode @n
# @code
# >>> y = vp.arange(3, dtype=float)
# >>> y
# array([0., 1., 2.])
# >>> vp.ones_like(y)
# array([1.,  1.,  1.])
# @endcode
#
# @endpydoc
# @endif
def ones_like(a, dtype=None, order='K', subok=False, shape=None):
    if subok is not False:
        raise NotImplementedError('subok in ones_like is not implemented yet.')

    a = nlcpy.asanyarray(a)

    if shape is None:
        shape = a.shape
    if dtype is None:
        dtype = a.dtype
    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in ones_like is not implemented yet.')

    if order is None or order in 'kKaA':
        if a._f_contiguous and not a._c_contiguous:
            order = 'F'
        else:
            order = 'C'

    out = nlcpy.ndarray(shape=shape, dtype=dtype, order=order)
    out.fill(1)
    return out


## @fn zeros(shape, dtype=float, order='C'):
# @rename basic.zeros zeros nlcpy.zeros
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a new array of given shape and type, filled with zeros.
#
# @details
# @param shape : <em>int or sequence of ints</em> @n
#   Shape of the new array, e.g., <span class="pre">(2, 3)</span> or <span class="pre">2</span>.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   The desired dtype for the array, e.g, @b nlcpy.int64.
#   Default is @b nlcpy.float64.
#
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Whether to store multi-dimensional data in row-major (C-style)
#   or column-major (Fortran-style) order in memory.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of zeros with the given shape, dtype, and order.
#
# @sa
#   @li @ref zeros_like : Returns an array of %zeros with the same %shape
#                         and type as a given array.
#   @li @ref empty : Returns a new array of given %shape and type,
#                    without initializing entries.
#   @li @ref ones : Returns a new array of given %shape and type,
#                   filled with %ones.
#   @li @ref full : Returns a new array of given %shape and type,
#                   filled with fill_value.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.zeros(5)
# array([ 0.,  0.,  0.,  0.,  0.])
# @endcode @n
# @code
# >>> vp.zeros((5,), dtype=int)
# array([0, 0, 0, 0, 0])
# @endcode @n
# @code
# >>> vp.zeros((2, 1))
# array([[ 0.],
#        [ 0.]])
# @endcode @n
# @code
# >>> s = (2,2)
# >>> vp.zeros(s)
# array([[ 0.,  0.],
#        [ 0.,  0.]])
# @endcode @n
#
# @endpydoc
# @endif
def zeros(shape, dtype=float, order='C'):
    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in zeros is not implemented yet.')
    out = nlcpy.ndarray(shape=shape, dtype=dtype, order=order)
    out.fill(0)
    return out


## @fn zeros_like(a, dtype=None, order='K', subok=False, shape=None)
# @rename basic.zeros_like zeros_like nlcpy.zeros_like
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns an array of zeros with the same shape and type as a given array.
#
# @details
# @param a : <em>array_like</em> @n
#   The shape and dtype of @em a define these same attributes
#   of the returned array.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   Overrides the data type of the result.
#
# @param order : <em>{'C', 'F', 'A', or 'K'}, @b optional</em> @n
#   Overrides the memory layout of the result. 'C' means C-order, 'F' means
#   F-order, 'A' means 'F' if @em a is Fortran contiguous, 'C' otherwise.
#   'K' means match the layout of @em a as closely as possible.
#
# @param subok : <em>bool, @b optional</em> @n
#   Not implemented.
#
# @param shape : <em>int or sequence of ints, @b optional</em> @n
#   Overrides the shape of the result. If order='K' and the number of
#   dimensions is unchanged, will try to keep order, otherwise,
#   order='C' is implied.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of zeros with the same shape and type as @em a.
#
# @sa
#   @li @ref empty_like : Returns a new array with the same %shape and type
#                         as a given array.
#   @li @ref ones_like : Returns an array of %ones with the same %shape
#                        and type as a given array.
#   @li @ref full_like : Returns a %full array with the same %shape
#                        and type as a given array.
#   @li @ref zeros : Returns a new array of given %shape and type,
#                    filled with %zeros.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> x = vp.arange(6)
# >>> x = x.reshape((2, 3))
# >>> x
# array([[0, 1, 2],
#        [3, 4, 5]])
# >>> vp.zeros_like(x)
# array([[0, 0, 0],
#        [0, 0, 0]])
# @endcode @n
# @code
# >>> y = vp.arange(3, dtype=float)
# >>> y
# array([0., 1., 2.])
# >>> vp.zeros_like(y)
# array([0.,  0.,  0.])
# @endcode
#
# @endpydoc
# @endif
def zeros_like(a, dtype=None, order='K', subok=False, shape=None):
    if subok is not False:
        raise NotImplementedError('subok in zeros_like is not implemented yet.')

    a = nlcpy.asanyarray(a)

    if shape is None:
        shape = a.shape

    if dtype is None:
        dtype = a.dtype
    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in zeros_like is not implemented yet.')

    if order is None or order in 'kKaA':
        if a._f_contiguous and not a._c_contiguous:
            order = 'F'
        else:
            order = 'C'

    out = nlcpy.ndarray(shape=shape, dtype=dtype, order=order)
    out.fill(0)
    return out


## @fn full(shape, fill_value, dtype=None, order='C'):
# @rename basic.full full nlcpy.full
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a new array of given shape and type, filled with @em fill_value.
#
# @details
# @param shape : <em>int or sequence of ints</em> @n
#   Shape of the new array, e.g., <span class="pre">(2, 3)</span> or <span class="pre">2</span>.
#
# @param fill_value : <em>scalar</em> @n
#   Fill value.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   The desired dtype for the array, e.g, @b nlcpy.int64.
#   Default is @b nlcpy.float64.
#
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Whether to store multidimensional data in C- or Fortran-contiguous
#   (row- or column-wise) order in memory.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of @em fill_value with the given shape, dtype, and order.
#
# @sa
#   @li @ref full_like : Returns a %full array with the same %shape
#                        and type as a given array.
#   @li @ref empty : Returns a new array of given %shape and type,
#                    without initializing entries.
#   @li @ref ones : Returns a new array of given %shape and type,
#                   filled with %ones.
#   @li @ref zeros : Returns a new array of given %shape and type,
#                    filled with %zeros.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.full((2, 2), vp.inf)
# array([[inf, inf],
#        [inf, inf]])
# >>> vp.full((2, 2), 10)
# array([[10, 10],
#        [10, 10]])
# @endcode
#
# @endpydoc
# @endif
def full(shape, fill_value, dtype=None, order='C'):
    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in full is not implemented yet.')

    if dtype is None:
        dtype = numpy.result_type(fill_value)

    if numpy.isscalar(fill_value):
        if numpy.iscomplex(fill_value):
            if dtype in ('complex64', 'complex128'):
                pass
            else:
                fill_value = numpy.real(fill_value)
                warnings.warn(
                    'Casting complex values to real discards the imaginary part',
                    numpy.ComplexWarning, stacklevel=2)
        out = nlcpy.ndarray(shape=shape, dtype=dtype, order=order)
        out.fill(fill_value)

    elif fill_value is None:
        raise NotImplementedError('fill_value in nlcpy.full is None')

    else:
        fill_value = nlcpy.array(fill_value)
        out = nlcpy.broadcast_to(fill_value, shape=shape)

    return out


## @fn full_like(a, fill_value, dtype=None, order='K', subok=False, shape=None)
# @rename basic.full_like full_like nlcpy.full_like
# @ingroup Ones_and_zeros
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a full array with the same shape and type as a given array.
#
# @details
# @param a : <em>array_like</em> @n
#   The shape and dtype of @em a define these same attributes of
#   the returned array.
#
# @param fill_value : <em>scalar</em> @n
#   Fill value.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   Overrides the data type of the result.
#
# @param order : <em>{'C', 'F', 'A', or 'K'}, @b optional</em> @n
#   Overrides the memory layout of the result. 'C' means C-order, 'F' means
#   F-order, 'A' means 'F' if @em a is Fortran contiguous, 'C' otherwise.
#   'K' means match the layout of @em a as closely as possible.
#
# @param subok : <em>bool, @b optional</em> @n
#   Not implemented.
#
# @param shape : <em>int or sequence of ints, @b optional</em> @n
#   Overrides the shape of the result. If order='K' and the number of
#   dimensions is unchanged, will try to keep order, otherwise,
#   order='C' is implied.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array of @em fill_value with the same shape and type as @em a.
#
# @sa
#   @li @ref empty_like : Returns a new array with the same %shape
#                         and type as a given array.
#   @li @ref ones_like : Returns an array of %ones with the same %shape
#                        and type as a given array.
#   @li @ref zeros_like : Returns an array of %zeros with the same %shape
#                         and type as a given array.
#   @li @ref full : Returns a new array of given %shape and type,
#                   filled with fill_value.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> x = vp.arange(6, dtype=int)
# >>> vp.full_like(x, 1)
# array([1, 1, 1, 1, 1, 1])
# >>> vp.full_like(x, 0.1)
# array([0, 0, 0, 0, 0, 0])
# >>> vp.full_like(x, 0.1, dtype=vp.double)
# array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
# >>> vp.full_like(x, vp.nan, dtype=vp.double)
# array([nan, nan, nan, nan, nan, nan])
# @endcode @n
# @code
# >>> y = vp.arange(6, dtype=vp.double)
# >>> vp.full_like(y, 0.1)
# array([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])
# @endcode
#
# @endpydoc
# @endif
def full_like(a, fill_value, dtype=None, order='K', subok=False, shape=None):
    if subok is not False:
        raise NotImplementedError('subok in full_like is not implemented yet.')

    a = nlcpy.asanyarray(a)
    if shape is None:
        shape = a.shape
    if dtype is None:
        dtype = a.dtype

    if numpy.dtype(dtype).kind == 'V':
        raise NotImplementedError('void dtype in full_like is not implemented yet.')

    if order is None or order in 'kKaA':
        if a._f_contiguous and not a._c_contiguous:
            order = 'F'
        else:
            order = 'C'

    if numpy.isscalar(fill_value):
        if numpy.iscomplex(fill_value):
            if dtype in ('complex64', 'complex128'):
                pass
            else:
                fill_value = numpy.real(fill_value)
                warnings.warn(
                    'Casting complex values to real discards the imaginary part',
                    numpy.ComplexWarning, stacklevel=2)
        out = nlcpy.ndarray(shape=shape, dtype=dtype, order=order)
        out.fill(fill_value)

    elif fill_value is None:
        raise NotImplementedError('fill_value in nlcpy.full_like is None')

    else:
        fill_value = nlcpy.array(fill_value)
        out = nlcpy.broadcast_to(fill_value, shape=shape)

    return out
## @}
