#
# * The source code in this file is developed independently by NEC Corporation.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
import numpy
import nlcpy
from nlcpy.core import core
from nlcpy.core import internal
from nlcpy import ndarray

# ----------------------------------------------------------------------------
# create arrays from existing data
# see: https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html
# ----------------------------------------------------------------------------

##
# @name create an array from existing data
# @{
#
## @fn array(object, dtype=None, copy=True, order='K', subok = False, ndmin=0)
# @rename from_data.array array nlcpy.array
# @ingroup From_existing_data
# @if(lang_ja)
# @else
# @pydoc
# @brief Creates an array.
#
# @details 
# @param object : <em>array_like</em> @n
#   An array, any object exposing the array interface, an object whose
#   \__array\__ method returns an array, or any (nested) sequence.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   The desired dtype for the array.
#   If not given, then the type will be determined as the minimum type
#   required to hold the objects in the sequence.
#   This argument can only be used to 'upcast' the array. For downcasting,
#   use the .astype(t) method.
#
# @param copy : <em>bool, @b optional</em> @n
#   If true (default), then the object is copied.
#   Otherwise, a copy will only be made if \__array\__ returns a copy,
#   if object is a nested sequence, or if a copy is needed to satisfy any
#   of the other requirements (@em dtype, @em order, etc.).
#
# @param order : <em>{'K', 'A', 'C', 'F'}, @b optional</em> @n
#   Specify the memory layout of the array. If object is not an array,
#   the newly created array will be in C order (row major) unless 'F' is
#   specified, in which case it will be in Fortran order (column major).
#   If object is an array the following holds.
# | order | no copy   | copy=True                                           |
# |:------|:----------|:----------------------------------------------------|
# | 'K'   | unchanged | F & C order preserved, otherwise most similar order |
# | 'A'   | unchanged | F order if input is F and not C, otherwise C order  |
# | 'C'   | C order   | C order                                             |
# | 'F'   | F order   | F order                                             |
#
#   When <span class="pre">copy=False</span> and a copy is made for other reasons,
#   the result is the same as if <span class="pre">copy=True</span>, with some
#   exceptions for @a A, see the Notes section. The default order is 'K'.
#
# @param subok : <em>bool, @b optional</em> @n
#   If True, then sub-classes will be passed-through, otherwise, the returned
#   array will be forced to be a base-class array (default).
#   subok=True is Not Implemented.
#
# @param ndmin : <em>int, @b optional</em> @n
#   Specifies the minimum number of dimensions that the resulting array
#   should have. Ones will be prepended to the shape as needed to meet
#   this requirement.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   An array object satisfying the specified requirements.
#
# @attention
# @raise object[i].shape not equals to object[j].shape for some i,j :
#                                                 @em NotImplementedError occurs.
#
# @sa
#   @li @ref basic.empty_like "empty_like" : Returns a new %array with the same
#                                            %shape and type as a given %array.
#   @li @ref basic.ones_like  "ones_like"  : Returns an %array of ones with
#                                   the same %shape and type as a given %array.
#   @li @ref basic.zeros_like "zeros_like" : Returns an %array of zeros
#                               with the same %shape and type as a given %array.
#   @li @ref basic.full_like  "full_like"  : Returns a full %array
#                               with the same %shape and type as a given %array.
#   @li @ref basic.empty      "empty"      : Returns a new %array of given
#                                 %shape and type, without initializing entries.
#   @li @ref basic.ones       "ones"       : Returns a new %array of given
#                                             %shape and type, filled with ones.
#   @li @ref basic.zeros      "zeros"      : Returns a new %array of given
#                                            %shape and type, filled with zeros.
#   @li @ref basic.full       "full"       : Returns a new %array of given
#                                       %shape and type, filled with fill_value.
#
# @note
#   When @em order is 'A' and @em object is an array in neither 'C' nor 'F'
#   order, and a copy is forced by a change in dtype,
#   then the order of the result is not necessarily 'C' as expected.
#   This is likely a bug.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.array([1, 2, 3])
# array([1, 2, 3])
# @endcode @n
# Upcasting:
# @code
# >>> vp.array([1, 2, 3.0])
# array([ 1.,  2.,  3.])
# @endcode @n
# More than one dimension:
# @code
# >>> vp.array([[1, 2], [3, 4]])
# array([[1, 2],
#        [3, 4]])
# @endcode @n
# Minimum dimensions 2:
# @code
# >>> vp.array([1, 2, 3], ndmin=2)
# array([[1, 2, 3]])
# @endcode @n
# Type provided:
# @code
# >>> vp.array([1, 2, 3], dtype=complex)
# array([ 1.+0.j,  2.+0.j,  3.+0.j])
# @endcode @n
#
# @endpydoc
# @endif

def array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0):
    if subok is not False:
        raise NotImplementedError('subok in array is not implemented yet.')
    return core.array(object, dtype, copy, order, subok, ndmin)


## @fn copy(a, order='K')
# @ingroup From_existing_data
# @rename from_data.copy copy nlcpy.copy
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns an array copy of the given object.
# @details 
# @param a : <em>array_like</em> @n
#   Input data.
# @param order : <em>{'C', 'F', 'A', 'K'}, @b optional</em> @n
#   Controls the memory layout of the copy.
#   'C' means C-order, 'F' means F-order, 'A' means 'F' if @em a is Fortran
#   contiguous, 'C' otherwise.
#   'K' means match the layout of @em a as closely as possible.
#   (Note that this function and @ref core::copy are very similar, but have
#   different default values for their order= arguments.)
# @retval arr : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array interpretation of @em a.
#
# @note
# This is equivalent to:
# @code
# >>> import nlcpy as vp
# >>> vp.array(a, copy=True)
# @endcode @n
#
# @par Example
# Create an array x, with a reference y and a copy z:
# @code
# >>> import nlcpy as vp
# >>> x = vp.array([1, 2, 3])
# >>> y = x
# >>> z = vp.copy(x)
# @endcode @n
# Note that when we modify x, y changes, but not z:
# @code
# >>> x[0] = 10
# >>> x[0] == y[0]
# True
# >>> x[0] == z[0]
# False
# @endcode @n
#
# @endpydoc
# @endif
def copy(a, order='K'):
    a = nlcpy.asanyarray(a)
    return a.copy(order=order)


## @fn asarray(a, dtype=None, order=None)
# @ingroup From_existing_data
# @rename from_data.asarray asarray nlcpy.asarray
# @if(lang_ja)
# @else
# @pydoc
# @brief Converts the input to an array.
#
# @details 
# @param a : <em>array_like</em> @n
#   Input data, in any form that can be converted to an array.
#   This includes scalars, lists, lists of tuples, tuples, tuples of tuples,
#   tuples of lists and ndarrays.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   By default, the dtype is inferred from the input data.
#
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Whether to use row-major (C-style) or column-major (Fortran-style)
#   memory representation. Defaults to 'C'.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   Array interpretation of @em a.
#   No copy is performed if the input is already an ndarray with matching
#   and order. If @em a is a subclass of ndarray, a base class ndarray is
#   returned.
#
# @sa
#   @li @ref asanyarray : Converts the input to an %array, but pass ndarray
#                         subclasses through.
#
# @par Example
# Convert a list into an array:
#
# @code
# >>> import nlcpy as vp
# >>> a = [1, 2]
# >>> vp.asarray(a)
# array([1, 2])
# @endcode @n
#
# Existing arrays are not copied:
# @code
# >>> a = vp.array([1, 2])
# >>> vp.asarray(a) is a
# True
# @endcode @n
#
# If @em dtype is set, array is copied only if dtype does not match:
# @code
# >>> a = vp.array([1, 2], dtype=vp.float32)
# >>> vp.asarray(a, dtype=vp.float32) is a
# True
# >>> vp.asarray(a, dtype=vp.float64) is a
# False
# @endcode @n
# @endpydoc
# @endif
def asarray(a, dtype=None, order=None):
    if type(a) is ndarray:
        if dtype is None and order is None:
            return a
        elif dtype is not None and order is None:
            if a.dtype == numpy.dtype(dtype):
                return a
        elif dtype is None and order is not None:
            order_char = internal._normalize_order(order)
            order_char = chr(core._update_order_char(a, order_char))
            if order_char == 'C' and a._c_contiguous:
                return a
            if order_char == 'F' and a._f_contiguous:
                return a
        else:
            order_char = internal._normalize_order(order)
            order_char = chr(core._update_order_char(a, order_char))
            if a.dtype == numpy.dtype(dtype) and \
                (order_char == 'C' and a._c_contiguous
                 or order_char == 'F' and a._f_contiguous):
                return a
    return core.array(a, dtype=dtype, order=order)


## @fn asanyarray(a, dtype=None, order=None)
# @ingroup From_existing_data
# @rename from_data.asanyarray asanyarray nlcpy.asanyarray
# @if(lang_ja)
# @else
# @pydoc
# @brief Converts the input to an array, but passes ndarray subclasses through.
#
# @details 
# @param a : <em>array_like</em> @n
#   Input data, in any form that can be converted to an array.
#   This includes scalars, lists, lists of tuples, tuples, tuples of tuples,
#   tuples of lists and ndarrays.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   By default, the dtype is inferred from the input data.
#
# @param order : <em>{'C', 'F'}, @b optional</em> @n
#   Whether to use row-major (C-stype) or column-major (Fortran-style) memory
#   representation. Defaults to 'C'.
#
# @retval out : <em>@ref n-dimensional_array "ndarray" or an ndarray subclass</em> @n
#   Array interpretation of @em a. If @em a is a subclass of ndarray,
#   it is returned as-is and no copy is performed.
#
# @sa
#   @li @ref asarray           : Converts the input to an %array.
#
# @par Example
#   Convert a list into an array:
#
# @code
# >>> import nlcpy as vp
# >>> a = [1, 2]
# >>> vp.asanyarray(a)
# array([1, 2])
# @endcode
#
# @endpydoc
# @endif
def asanyarray(a, dtype=None, order=None):
    if isinstance(a, ndarray):
        if dtype is None and order is None:
            return a
        elif dtype is not None and order is None:
            if a.dtype == numpy.dtype(dtype):
                return a
        elif dtype is None and order is not None:
            order_char = internal._normalize_order(order)
            order_char = chr(core._update_order_char(a, order_char))
            if order_char == 'C' and a._c_contiguous:
                return a
            if order_char == 'F' and a._f_contiguous:
                return a
        else:
            order_char = internal._normalize_order(order)
            order_char = chr(core._update_order_char(a, order_char))
            if a.dtype == numpy.dtype(dtype) and \
                (order_char == 'C' and a._c_contiguous
                 or order_char == 'F' and a._f_contiguous):
                return a
    return core.array(a, dtype=dtype, order=order)

# @}
