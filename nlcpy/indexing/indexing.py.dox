#
# * The source code in this file is developed independently by NEC Corporation.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import nlcpy


## @fn take(a, indices, axis=None, out=None)
# @rename indexing.take take nlcpy.take
# @if(lang_ja)
# @else
# @pydoc
# @brief Takes elements from an array along an axis.
#
# @details
#   When axis is not None, this function does the same thing as "fancy"
#   indexing (indexing arrays using arrays);
#   however, it can be easier to use if you need elements along a given
#   axis. A call such as
#   <span class="pre">arr.take(indices, axis=3)</span> is equivalent to
#   <span class="pre">arr[:,:,:,indices,...]</span>.
#
# @param a : <em>array_like</em> @n
#   The source array.
#
# @param indices : <em>array_like</em> @n
#   The indices of the values to extract.
#   Also allow scalars for indices.
#
# @param axis : <em>int, @b optional</em> @n
#   The axis over which to select values. By default, the flattened 
#   input array is used.
#
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   If provided, the result will be placed in this array. It should be 
#   of the appropriate shape and dtype.
#   Note that @em out is always buffered if <em>mode='raise'</em>; use 
#   other modes for better performance.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#
# @attention
# This function does not support @em mode argument.
# If @em indices are out-of-bounds, this function always wraps around 
# them.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([4, 3, 5, 7, 6, 8])
# >>> indices = [0, 1, 4]
# >>> vp.take(a, indices)
# array([4, 3, 6])
# @endcode @n
# In this example, "fancy" indexing can be used.
# @code
# >>> a[indices]
# array([4, 3, 6])
# @endcode @n
# If indices is not one dimensional, the output also has these 
# dimensions.
# @code
# >>> vp.take(a, [[0, 1], [2, 3]])
# array([[4, 3],
#       [5, 7]])
# @endcode
#
# @endpydoc
# @endif
def take(a, indices, axis=None, out=None):
    a = nlcpy.asarray(a)
    return a.take(indices, axis, out)


##
# @name Generating index arrays
# @{
#
## @fn diagonal(a, offset=0, axis1=0, axis2=1)
# @rename indexing.diagonal diagonal nlcpy.diagonal
# @ingroup Generating_index_arrays
# @if(lang_ja)
# @else
# @pydoc
# @brief 
#   Returns specified diagonals.
#
# @details
# If <em>a</em> is 2-D, returns the diagonal of <em>a</em> with the given offset, i.e.,
# the collection of elements of the form <span class="pre">a[i, i+offset]</span>. 
# If <em>a</em> has more than two dimensions, then the axes specified by <em>axis1</em>
# and <em>axis2</em> are used to determine the 2-D sub-array whose diagonal is 
# returned. 
# The shape of the resulting array can be determined by removing <em>axis1</em> 
# and <em>axis2</em> and appending an index to the right equal to the size of 
# the resulting diagonals.@n@n
# This function returns a writable view of the original array.
#
# @param a : <em>array_like</em> @n
#   Array from which the diagonals are taken.
#
# @param offset : <em>int, @b optional</em> @n
# Offset of the diagonal from the main diagonal. 
# Can be positive or negative. Defaults to main diagonal (0).
#
# @param axis1 : <em>int, @b optional</em> @n
# Axis to be used as the first axis of the 2-D sub-arrays from which 
# the diagonals should be taken.
# Defaults to first axis (0).
#
# @param axis2 : <em>int, @b optional</em> @n
# Axis to be used as the second axis of the 2-D sub-arrays from which 
# the diagonals should be taken.
# Defaults to second axis (1).
#
# @retval array_of_diagonals : <em>@ref n-dimensional_array "ndarray"</em> @n
# If <em>a</em> is 2-D, then a 1-D array containing the diagonal and of 
# the same type as <em>a</em> is returned.
# If <span class="pre">a.ndim > 2</span>, then the dimensions specified by <em>axis1</em>
# and <em>axis2</em> are removed, and a new axis inserted at the end
# corresponding to the diagonal.
#
# @note
#   @li <span class="pre">a.ndim < 2</span> : @em ValueError occurs.
#
# @sa 
#   @li @ref matrices::diag "nlcpy.diag" : Extracts a %diagonal or
#       constructs a %diagonal array.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.arange(4).reshape(2,2)
# >>> a
# array([[0, 1],
#        [2, 3]])
# >>> a.diagonal()
# array([0, 3])
# >>> a.diagonal(1)
# array([1])
# @endcode @n
# A 3-D example:
# @code
# >>> a = vp.arange(8).reshape(2,2,2); a
# array([[[0, 1],
#         [2, 3]],
#        [[4, 5],
#         [6, 7]]])
# >>> a.diagonal(0,  # Main diagonals of two arrays created by skipping
# ...            0,  # across the outer(left)-most axis last and
# ...            1)  # the "middle" (row) axis first.
# array([[0, 6],
#        [1, 7]])
# @endcode @n
# The sub-arrays whose main diagonals we just obtained;
# note that each corresponds to fixing the right-most (column) axis,
# and that the diagonals are “packed” in rows.
# @code
# >>> a[:,:,0]  # main diagonal is [0 6]
# array([[0, 2],
#        [4, 6]])
# >>> a[:,:,1]  # main diagonal is [1 7]
# array([[1, 3],
#        [5, 7]])
# @endcode @n
#
#
# @endif
#
def diagonal(a, offset=0, axis1=0, axis2=1):
    a = nlcpy.asarray(a)
    return a.diagonal(offset, axis1, axis2)
## @}
