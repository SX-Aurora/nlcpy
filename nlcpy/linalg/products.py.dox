#
# * The source code in this file is developed independently by NEC Corporation.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

import nlcpy
import numpy
from nlcpy.ufunc import operations as ufunc_op
from nlcpy.linalg import cblas_wrapper


## @fn dot(a, b, out=None)
# @rename products.dot dot nlcpy.dot
# @if(lang_ja)
# @else
# @pydoc
# @brief Computes a dot product of two arrays.
#
# @details
# @li If both @em a and @em b are 1-D arrays,
#     it is inner product of vectors (without complex conjugation).
# @li If both @em a and @em b are 2-D arrays, it is matrix multiplication,
#     but using @ref ufuncs::matmul or <span class="pre">a @ b</span> is preferred.
# @li If either @em a or @em b is 0-D (scalar), it is equivalent to multiply
#     and using <span class="pre">nlcpy.multiply(a,b)</span> or
#     <span class="pre">a * b</span> is preferred.
# @param a : <em>array_like</em> @n
#   Input arrays or scalars.
#
# @param b : <em>array_like</em> @n
#   Input arrays or scalars.
#
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   Output argument. This must have the exact kind that would be
#   returned if it was not used.
#   In particular, @em out.dtype must be the dtype that would be
#   returned for @em dot(a,b).
#
# @retval output : <em>@ref n-dimensional_array "ndarray" </em> @n
#   Returns the dot product of @em a and @em b.
#   If @em a and @em b are both scalars or both 1-D arrays
#   then this function returns the result as a 0-dimention array.
#
# @attention
#   @raise  <span class="pre">a.ndim>2</span> or <span class="pre">b.ndim>2</span> :
#           @em NotImplementedError occurs.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.dot(3, 4)
# array(12)
# @endcode@n
# Neither argument is complex-conjugated:
# @code
# >>> vp.dot([2j, 3j], [2j, 3j])
# array([-13.+0.j])
# @endcode@n
# For 2-D arrays it is the matrix product:
# @code
# >>> a = [[1, 0], [0, 1]]
# >>> b = [[4, 1], [2, 2]]
# >>> vp.dot(a,b)
# array([[4, 1],
#        [2, 2]])
# @endcode@n
# @endpydoc
#
# @endif
def dot(a, b, out=None):
    a = nlcpy.asanyarray(a)
    b = nlcpy.asanyarray(b)
    if out is not None and \
            numpy.result_type(a.dtype, b.dtype) != out.dtype:
        raise ValueError('output array is incorrect dtype')
    # if either a or b is 0-D array, it is equivalent to nlcpy.multiply
    if a.ndim == 0 or b.ndim == 0:
        return ufunc_op.multiply(a, b, out=out)
    # if both a and b are 1-D arrays, it is inner product of vectors
    if a.ndim == 1 and b.ndim == 1:
        return cblas_wrapper.cblas_dot(a, b, out=out)
    # if both a and b are 2-D arrays, it is matrix multiplication
    if a.ndim == 2 and b.ndim == 2:
        return cblas_wrapper.cblas_gemm(
            a, b, out=out, dtype=numpy.result_type(a.dtype, b.dtype))

    # TODO:
    # if either a or b are N-D array, it is sum product over the
    # last(or second-last) axis.
    raise NotImplementedError(
        'array \'a\' or \'b\' are N-D array case is not implemented yet.')
