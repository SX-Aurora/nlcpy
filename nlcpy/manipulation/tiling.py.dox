#
# * The source code in this file is developed independently by NEC Corporation.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
import numpy
from nlcpy.core import core
from nlcpy.core.core import ndarray, array
from nlcpy.request import request

import functools
import operator


##
# @name Tiling arrays
# @{
#
## @fn tile(A, reps)
# @rename tiling.tile tile nlcpy.tile
# @ingroup Tiling_arrays
# @if(lang_ja)
# @else
# @pydoc
# @brief Constructs an array by repeating A the number of times given by reps.
#
# @details
#  If @em reps has length <span class="pre">d</span>, the result will have
#  dimension of <span class="pre">max(d, A.ndim)</span>. @n
#  If <span class="pre">A.ndim < d</span>, @em A is promoted to be
#  d-dimensional by prepending new axes. So a shape (3,) array is promoted
#  to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication.
#  If this is not the desired behavior, promote @em A to d-dimensions manually
#  before calling this function. @n
#  If <span class="pre">A.ndim > d</span>, @em reps is promoted to @em A.ndim
#  by pre-pending 1's to it. Thus for an @em A of shape (2, 3, 4, 5),
#  a @em reps of (2, 2) is treated as (1, 1, 2, 2). @n
# @note
#  Although tile may be used for broadcasting, it is strongly recommended
#  to use nlcpy's broadcasting operations and functions.
#
# @param A : <em>array_like</em> @n
#  The input array.
#
# @param reps : <em>array_like</em> @n
#  The number of repetitions of @em A along each axis.
#
# @retval c : <em>@ref n-dimensional_array "ndarray"</em> @n
#  The tiled output array.
#
# @sa
# @li @ref dims.broadcast_to "broadcast_to" : Broadcasts an array to a new %shape.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([0, 1, 2])
# >>> vp.tile(a, 2)
# array([0, 1, 2, 0, 1, 2])
# >>> vp.tile(a, (2, 2))
# array([[0, 1, 2, 0, 1, 2],
#        [0, 1, 2, 0, 1, 2]])
# >>> vp.tile(a, (2, 1, 2))
# array([[[0, 1, 2, 0, 1, 2]],
#        [[0, 1, 2, 0, 1, 2]]])
# @endcode @n
# @code
# >>> b = vp.array([[1, 2], [3, 4]])
# >>> vp.tile(b, 2)
# array([[1, 2, 1, 2],
#        [3, 4, 3, 4]])
# >>> vp.tile(b, (2, 1))
# array([[1, 2],
#        [3, 4],
#        [1, 2],
#        [3, 4]])
# @endcode @n
# @code
# >>> c = vp.array([1,2,3,4])
# >>> vp.tile(c,(4,1))
# array([[1, 2, 3, 4],
#        [1, 2, 3, 4],
#        [1, 2, 3, 4],
#        [1, 2, 3, 4]])
# @endcode
# @endpydoc
# @endif
#
def tile(A, reps):

    if not isinstance(A, ndarray):
        A = core.argument_conversion(A)

    # TODO: numpy.isscalar -> nlcpy.isscalar
    if numpy.isscalar(reps) or reps is None:
        shape_reps = (reps,)
        dim_reps = len(shape_reps)
    elif isinstance(reps, (ndarray, numpy.ndarray)):
        if reps.ndim == 0:
            shape_reps = (reps,)
        elif reps.ndim == 1:
            shape_reps = tuple([reps[i] for i in range(reps.size)])
        elif reps.ndim > 1:
            raise ValueError("The truth value of an array with more than"
                             + " one element is ambiguous. "
                             + "Use a.any() or a.all()")
        dim_reps = reps.size
    elif isinstance(reps, (list, tuple)):
        reps_size = 1
        if len(reps) <= 0:
            reps = (1,)
        else:
            if A.ndim in [0, 1, 2]:
                inner_cnt = 1
            else:
                inner_cnt = functools.reduce(operator.mul, A.shape[0:-1])

            for i in range(len(reps)):
                if isinstance(reps[i], (list, tuple)):
                    if len(reps[i]) <= 0:
                        raise ValueError("operands could not be broadcast"
                                         + " together with shape ("
                                         + str(reps_size * inner_cnt)
                                         + ",) (0,)")
                    if len(reps[i]) == 1:
                        if isinstance(reps[i][0], (list, tuple)):
                            raise ValueError(
                                "object too deep for desired array")
                        else:
                            raise TypeError("'%s' object cannot be"
                                            " interpreted as an integer"
                                            % (type(reps[i]).__name__))
                    elif len(reps[i]) > 1:
                        list_flg = False
                        scal_flg = False
                        for j in range(len(reps[i])):
                            if isinstance(reps[i][j], (list, tuple)):
                                list_flg = True
                            # TODO: numpy.isscalar -> nlcpy.isscalar
                            elif numpy.isscalar(reps[i][j]):
                                scal_flg = True
                            elif isinstance(reps[i][j], (ndarray, numpy.ndarray)):
                                if reps[i][j].size == 1:
                                    scal_flg = True
                                elif reps[i][j].size <= 0 or reps[i][j].size >= 2:
                                    list_flg = True

                        if list_flg is True and scal_flg is True:
                            raise ValueError(
                                "setting an array element with a sequence.")
                        elif not list_flg and scal_flg:
                            raise ValueError("operands could not be broadcast"
                                             + " together with shape ("
                                             + str(reps_size * inner_cnt)
                                             + ",) (" + str(len(reps[i]))
                                             + ",)")
                        elif list_flg and not scal_flg:
                            raise ValueError(
                                "object too deep for desired array")

                elif isinstance(reps[i], (ndarray, numpy.ndarray)):
                    if reps[i].size > 1 and reps.ndim > 0:
                        raise ValueError(
                            "The truth value of an array with more than"
                            + " one element is ambiguous."
                            + " Use a.any() or a.all()")
                    else:
                        if reps[i].ndim == 0:
                            shape_reps = (reps[i],)
                        elif reps[i].ndim == 1:
                            shape_reps = (reps[i],)

                elif reps[i] is not None and not isinstance(reps[i], int):
                    if isinstance(reps[i], complex):
                        reps_size *= int(reps[i].real)
                    else:
                        reps_size *= int(reps[i])

        shape_reps = tuple(reps)
        dim_reps = len(shape_reps)

    if A.ndim < dim_reps:
        A = array(A, ndmin=dim_reps)

    shape_A = A.shape
    shape_reps = (1,) * (A.ndim - dim_reps) + shape_reps
    shape = tuple(s * t for s, t in zip(shape_A, shape_reps))
    ret = ndarray(shape=shape, dtype=A.dtype)

    if ret.size > 0:
        request._push_request(
            'nlcpy_tile',
            'manipulation_op',
            (A, ret)
        )
    return ret
## @}
