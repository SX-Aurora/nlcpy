#
# * The source code in this file is based on the soure code of NumPy.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# # NumPy License #
#
#     Copyright (c) 2005-2020, NumPy Developers.
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither the name of the NumPy Developers nor the names of any contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

# distutils: language = c++

import nlcpy
import numpy

from nlcpy import veo
from nlcpy.core cimport vememory
from nlcpy.core cimport core
from nlcpy.core.core import ndarray
from nlcpy.ufunc import operations as ufunc
from nlcpy.core cimport broadcast
from nlcpy.core.core cimport *
from nlcpy.core.error import _AxisError as AxisError
from nlcpy.core.dtype cimport get_dtype_number, get_dtype
from nlcpy.request cimport request

# ----------------------------------------------------------------------------
# Mathematical functions (except for universel functions)
# see: https://docs.scipy.org/doc/numpy/reference/routines.math.html
# ----------------------------------------------------------------------------

##
## @name Mathematical Functions
## @{

## @fn sum(a, axis=None, dtype=None, out=None, keepdims=nlcpy._NoValue, initial=nlcpy._NoValue, where=nlcpy._NoValue)
# @rename math.sum sum nlcpy.sum
# @if(lang_ja)
# @else
# @pydoc
# @brief Sum of array elements over a given axis.
#
# @details
# @param a : <em>array_like</em> @n
#   Elements to sum.
#
# @param axis : <em>None or int or tuple of ints, @b optional</em> @n
#   Axis or axes along which a sum is performed. The default, axis=None,
#   will sum all of the elements of the input array. If axis is negative
#   it counts from the last to the first axis.
#   If axis is a tuple of ints, a sum is performed on all of the axes
#   specified in the tuple instead of a single axis or all the axes as before.
#
# @param dtype : <em>dtype, @b optional</em> @n
#   The type used to represent the intermediate results. Defaults to the dtype
#   of the output array if this is provided.
#   If out is not provided, the dtype of @em a is used unless @em a has
#   @b nlcpy.int32 or @b nlcpy.uint32.
#   In that case, @b nlcpy.int64 or @b nlcpy.uint64 is used.
#
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   Alternative output array in which to place the result. It must have
#   the same shape as the expected output, but the type of the output values
#   will be cast if necessary.
#
# @param keepdims : <em>bool, @b optional</em> @n
#   If this is set to True, the axes which are reduced are left in the result
#   as dimensions with size one. With this option, the result will broadcast
#   correctly against the original array.
#
# @param initial : <em>scalar, @b optional</em> @n
#   The value with which to start the reduction. Defaults to 0.
#   If None is given, the first element of the reduction is used, and an error
#   is thrown if the reduction is empty.
#
# @param where : <em>array_like of bool, @b optional</em> @n
#   A boolean array which is broadcasted to match the dimensions of @em a,
#   and selects elements to include in the reduction.
#
# @retval sum_along_axis : <em>@ref n-dimensional_array "ndarray"</em> @n
#   An array with the same shape as @em a, with the specified axis removed.
#   If @em a is a 0-d array, or if @em axis is None, this function returns
#   the result as a 0-dimention array.
#   If an output array is specified, a reference to @em out is returned.
#
# @sa
# @li @ref cumsum : Returns the cumulative %sum of the elements along a given axis.
# @li @ref average.mean "mean" : Computes the arithmetic mean along the specified axis.
# @li @ref average.average "average" : Computes the weighted average along the specified axis.
#
# @note
# @li @ref ufunc::reduce "nlcpy.reduce.add" is called in this function.
# @li Arithmetic is modular when using integer types, and no error is raised
# on overflow. @n
# @li The sum of an empty array is the neutral element 0:
# @code
# >>> import nlcpy as vp
# >>> vp.sum([])
# array(0.)
# @endcode
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.sum([0.5, 1.5])
# array(2.)
# >>> vp.sum([0.5, 0.7, 0.2, 1.5], dtype=vp.int32)
# array(1, dtype=int32)
# >>> vp.sum([[0, 1], [0, 5]])
# array(6)
# >>> vp.sum([[0, 1], [0, 5]], axis=0)
# array([0, 6])
# >>> vp.sum([[0, 1], [0, 5]], axis=1)
# array([1, 5])
# >>> vp.sum([[0, 1], [vp.nan, 5]], where=[False, True], axis=1)
# array([1., 5.])
# @endcode @n
# You can also start the sum with a value other than zero:
# @code
# >>> vp.sum([10], initial=5)
# array(15)
# @endcode
# @endpydoc
#
# @endif
def sum(a, axis=None, dtype=None, out=None, keepdims=nlcpy._NoValue,
        initial=nlcpy._NoValue, where=nlcpy._NoValue):
    if where is nlcpy._NoValue:
        where = True
    if keepdims is nlcpy._NoValue:
        keepdims = False
    return ufunc.add.reduce(a, axis=axis, dtype=dtype, out=out,
                            initial=initial, keepdims=keepdims,
                            where=where)


## @fn cumsum(a, axis=None, dtype=None, out=None)
# @rename math.cumsum cumsum nlcpy.cumsum
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns the cumulative sum of the elements along a given axis.
#
# @details
# @param a : <em>array_like</em> @n
#   Input array.
# @param axis : <em>int, @b optional</em> @n
#   Axis along which the cumulative sum is computed.
#   The default (None) is to compute the cumsum over the flattened array.
# @param dtype : <em>dtype, @b optional</em> @n
#   Type of the returned array and of the accumulator in which the elements
#   are summed. If dtype is not specified, it defaults to the dtype of @em a,
#   unless dtype is @b nlcpy.int32. unless dtype is @b nlcpy.int32.
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   Alternative output array in which to place the result.
#   It must have the same shape and buffer length as the expected output
#   but the type will be cast if necessary.
# @retval cumsum_along_axis : <em>@ref n-dimensional_array "ndarray"</em> @n
#   A new array holding the result is returned unless @em out is specified,
#   in which case a reference to @em out is returned.
#   The result has the same size as @em a, and the same shape as @em a
#   if @em axis is not None or @em a is a 1-d array.
# @sa
#   @li @ref sum : Sum of array elements over a given axis.
#   @li @ref diff : Calculates the n-th discrete difference along the given axis.
# @note
#   Arithmetic is modular when using integer types, and no error is raised
#   on overflow.
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([[1,2,3], [4,5,6]])
# >>> a
# array([[1, 2, 3],
#        [4, 5, 6]])
# >>> vp.cumsum(a)
# array([ 1,  3,  6, 10, 15, 21])
# >>> vp.cumsum(a, dtype=float)
# array([ 1.,  3.,  6., 10., 15., 21.])
# >>> vp.cumsum(a, axis=0)
# array([[1, 2, 3],
#        [5, 7, 9]])
# >>> vp.cumsum(a, axis=1)
# array([[ 1,  3,  6],
#        [ 4,  9, 15]])
# @endcode
# @endpydoc
# @endif
def cumsum(a, axis=None, dtype=None, out=None):
    a = core.argument_conversion(a)
    if a.ndim == 0:
        a = a.reshape(1)

    ########################################################################
    # TODO: VE-VH collaboration
    if a._memloc in {on_VH, on_VE_VH}:
        raise NotImplementedError("cumsum on VH is not yet impremented")

    ########################################################################
    # check order
    if a._f_contiguous and not a._c_contiguous:
        order_out = 'F'
    else:
        order_out = 'C'

    ########################################################################
    # axis check
    if axis is None:
        if a.ndim > 1:
            a = a.reshape(a.size)

        axis = 0
    elif isinstance(axis, nlcpy.ndarray) and axis.ndim > 0:
        raise TypeError(
            "only integer scalar arrays can be converted to a scalar index")
    elif not isinstance(axis, int):
        raise TypeError("'%s' object cannot be interpreted as an integer"
                        % (type(axis).__name__))
    else:
        if axis < 0:
            axis = a.ndim + axis
        if axis < 0 or axis > a.ndim-1:
            raise AxisError('axis ' + str(axis)
                            + ' is out of bounds for array of dimension ' + str(a.ndim))

    ########################################################################
    # dtype check
    if dtype is not None:
        if type(dtype) == str and dtype.find(',') > 0:
            raise TypeError('cannot perform cumsum with flexible type')
        dt = dtype
    elif a.dtype in ('bool', 'int32'):
        dt = 'int64'
    elif a.dtype == 'uint32':
        dt = 'uint64'
    else:
        dt = a.dtype

    ########################################################################
    # error check for "out"
    if out is not None:
        if type(out) != nlcpy.ndarray:
            raise TypeError("output must be an array")

        else:
            if a.ndim == 1:
                if a.shape[0] != out.shape[0]:
                    raise ValueError("provided out is the wrong size for the reduction")
                else:
                    y = out
            else:
                if a.ndim <= out.ndim:
                    for i in range(a.ndim):
                        if a.shape[i] != out.shape[i]:
                            raise ValueError("operands could not be broadcast together"
                                             + " with remapped shapes "
                                             + "[original->remapped]: "
                                             + str(out.shape).replace(" ", "") + "->"
                                             + str(out.shape[0:a.ndim]).replace(" ", "")
                                             + " " + str(a.shape).replace(" ", "")
                                             + "->" + str(a.shape).replace(" ", "")
                                             + " ")

                        # TODO: VE-VH collaboration
                        if out._memloc in {on_VH, on_VE_VH}:
                            raise NotImplementedError(
                                "cumsum on VH is not yet implemented.")
                    y = out
                else:
                    raise ValueError("Iterator input op_axes[0]["
                                     + str(a.ndim-out.ndim-1)+"] "
                                     + "(==" + str(out.ndim)
                                     + ") is not a valid axis of op[0], "
                                     + "which has " + str(out.ndim) + " dimensions ")
    else:
        y = core.ndarray(shape=a.shape, dtype=dt, order=order_out)

    if out is None or out.dtype == dt:
        w = y
    else:
        w = core.ndarray(shape=a.shape, dtype=dt, order=order_out)

    ########################################################################

    request._push_request(
        "nlcpy_add_accumulate",
        "accumulate_op",
        (a, y, w, axis, get_dtype_number(get_dtype(dt))),)
    return y


## @fn diff(a, n=1, axis=-1, prepend=nlcpy._NoValue, append=nlcpy._NoValue)
# @rename math.diff diff nlcpy.diff
# @if(lang_ja)
# @else
# @pydoc
# @brief Calculates the n-th discrete difference along the given axis.
# @details
#   The first difference is given by
#   <span class="pre">out[i] = a[i+1] - a[i]</span> along the given axis,
#   higher differences are calculated by using @ref diff recursively.
# @param a : <em>array_like</em> @n
#   Input array
# @param n : <em>int, @b optional</em> @n
#   The number of times values are differenced. If zero, the input is
#   returned as-is.
# @param axis : <em>int, @b optional</em> @n
#   The axis along which the difference is taken, default is the last axis.
# @param prepend, append : <em>array_like, @b optional</em> @n
#   Values to prepend or append to @em a along axis prior to performing
#   the difference. Scalar values are expanded to arrays with length 1
#   in the direction of axis and the shape of the input array in along
#   all other axes. Otherwise the dimension and shape must match @em a
#   except along axis.
# @retval diff : <em>@ref n-dimensional_array "ndarray"</em> @n
#   The n-th differences.
#   The shape of the output is the same as @em a except along @em axis where
#   the dimension is smaller by @em n. The type of the output is the same as
#   the type of the difference between any two elements of @em a.
# @sa
#   @li @ref cumsum : Returns the cumulative %sum of the elements along a given axis.
# @note
#   Type is preserved for boolean arrays, so the result will contain @em False
#   when consecutive elements are the same and @em True when they differ. @n
#   For unsigned integer arrays, the results will also be unsigned.
#   This should not be surprising, as the result is consistent with calculating
#   the difference directly:
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([1, 0], dtype='uint32')
# >>> vp.diff(a)
# array([4294967295], dtype=uint32)
# >>> vp.array([0], dtype='uint32') - vp.array([1], dtype='uint32')
# array([4294967295], dtype=uint32)
# @endcode @n
# if this is not desirable, then the array should be cast to
# a larger integer type first:
# @code
# >>> b = a.astype(vp.int64)
# >>> vp.diff(b)
# array([-1])
# @endcode
# @par Example
# @code
# >>> x = vp.array([1, 2, 4, 7, 0])
# >>> vp.diff(x)
# array([ 1,  2,  3, -7])
# >>> vp.diff(x, n=2)
# array([  1,   1, -10])
# @endcode @n
# @code
# >>> x = vp.array([[1, 3, 6, 10], [0, 5, 6, 8]])
# >>> vp.diff(x)
# array([[2, 3, 4],
#        [5, 1, 2]])
# >>> vp.diff(x, axis=0)
# array([[-1,  2,  0, -2]])
# @endcode @n
# @endpydoc
# @endif
def diff(a, n=1, axis=-1, prepend=nlcpy._NoValue, append=nlcpy._NoValue):
    if n == 0:
        return a
    if n < 0:
        raise ValueError("order must be non-negative but got " + repr(n))
    a = nlcpy.asanyarray(a)
    nd = a.ndim
    if nd == 0:
        raise ValueError('diff requires input that is at least one dimensional')

    if axis < -nd or nd <= axis:
        raise AxisError('axis {} is out of bounds for array of dimension {}'
                        .format(axis, nd))
    axis = (nd + axis) if axis < 0 else axis

    combined = []
    if prepend is not nlcpy._NoValue:
        prepend = nlcpy.asanyarray(prepend)
        if prepend.ndim == 0:
            shape = list(a.shape)
            shape[axis] = 1
            prepend = nlcpy.broadcast_to(prepend, tuple(shape))
        combined.append(prepend)

    combined.append(a)

    if append is not nlcpy._NoValue:
        append = nlcpy.asanyarray(append)
        if append.ndim == 0:
            shape = list(a.shape)
            shape[axis] = 1
            append = nlcpy.broadcast_to(append, tuple(shape))
        combined.append(append)

    if len(combined) > 1:
        a = nlcpy.concatenate(combined, axis)

    shape = list(a.shape)
    shape[axis] = max(0, shape[axis] - n)
    dtype_out = a.dtype
    order_out = 'C' if a._c_contiguous else 'F'
    out = nlcpy.ndarray(shape=shape, dtype=dtype_out, order=order_out)

    if out.size > 0:
        w = nlcpy.array(a)
        request._push_request(
            'nlcpy_diff',
            'math_op',
            (a, n, axis, out, w),
        )
    return out


## @fn angle(z, deg)
# @rename math.angle angle nlcpy.angle
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns the angle of the complex argument.
#
# @details
# @param z : <em>array_like</em> @n
#   A complex number or sequence of complex numbers.
#
# @param deg : <em>bool, @b optional</em> @n
#   Returns angle in degrees if True, radians if False (default).
#
# @retval angle : <em>@ref n-dimensional_array "ndarray"</em> @n
#   The counterclockwise angle from the positive real axis on the complex plane
#   in the range <span class="pre">(-pi, pi]</span>, with dtype as nlcpy.float64.
#   If @em z is a scalar, this function returns the result as a 0-dimention array.
#
# @sa
#   @li @ref ufuncs::arctan2 "arctan2" : Computes an element-wise inverse tangent
#                                        of @em x1/@em x2.
#   @li @ref ufuncs::absolute "absolute" : Computes an element-wise absolute value.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> vp.angle([1.0, 1.0j, 1+1j])               # in radians
# array([0.        , 1.57079633, 0.78539816]) ) # may vary
# >>> vp.angle(1+1j, deg=True)                  # in degrees
# array(45.)
# @endcode
# @endpydoc
#
# @endif
def angle(z, deg=False):
    x = nlcpy.asanyarray(z)

    if x.dtype in [numpy.dtype('complex64'), numpy.dtype('float32')]:
        dtype_out = numpy.dtype('float32')
    elif x.dtype in [numpy.dtype('complex128'), numpy.dtype('float64')]:
        dtype_out = numpy.dtype('float64')
    elif x.dtype in [numpy.dtype('int32'), numpy.dtype('int64'), numpy.dtype('uint32'),
                     numpy.dtype('uint64'), numpy.dtype('bool')]:
        dtype_out = numpy.dtype('float64')
    else:
        raise TypeError("Unknown datatype is specified")

    if x._c_contiguous:
        order_out = 'C'
    else:
        order_out = 'F'

    out = ndarray(x.shape, dtype=dtype_out, order=order_out)

    fpe_flags = numpy.empty(1, dtype=numpy.int32)
    args = (
        x._ve_array,
        out._ve_array,
        veo.OnStack(fpe_flags, inout=veo.INTENT_OUT),)
    v = veo.VeoAlloc()
    request.flush()
    req = v.lib.func[b'nlcpy_angle'](v.ctx, *args)
    ve_adr = req.wait_result()
    core.check_fpe_flags(fpe_flags[0])

    if deg:
        return nlcpy.rad2deg(out)
    else:
        return out


## @fn real(val)
# @rename math.real real nlcpy.real
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns the real part of the complex argument.
#
# @details
# @param val : <em>array_like</em> @n
#   Input arrays or scalars.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   The real component of the complex argument. If @em val is real, the type
#   of @em val is used for the output.
#   If @em val has complex elements, the returned type is float.
#   If @em val is a scalar, this function returns the result
#   as a 0-dimention array.
#
# @sa
#   @li @ref imag : Returns the imaginary part of the complex argument.
#   @li @ref angle : Returns the %angle of the complex argument.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([1+2j, 3+4j, 5+6j])
# >>> a.real
# array([1.,  3.,  5.])
# >>> a.real = 9
# >>> a
# array([9.+2.j,  9.+4.j,  9.+6.j])
# >>> a.real = vp.array([9, 8, 7])
# >>> a
# array([9.+2.j,  8.+4.j,  7.+6.j])
# >>> vp.real(1 + 1j)
# array(1.)
# @endcode
# @endpydoc
#
# @endif
def real(val):
    val = nlcpy.asarray(val)
    return val.real


## @fn imag(val)
# @rename math.imag imag nlcpy.imag
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns the imaginary part of the complex argument.
#
# @details
# @param val : <em>array_like</em> @n
#   Input arrays or scalars.
#
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
#   The imaginary component of the complex argument. If @em val is real,
#   the type of @em val is used for the output.
#   If @em val has complex elements, the returned type is float.
#   If @em val is a scalar, this function returns the result as a 0-dimention array.
#
# @sa
#   @li @ref real : Returns the %real part of the complex argument.
#   @li @ref angle : Returns the %angle of the complex argument.
#
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([1+2j, 3+4j, 5+6j])
# >>> a.imag
# array([2.,  4.,  6.])
# >>> a.imag = vp.array([8, 10, 12])
# >>> a
# array([1. +8.j,  3.+10.j,  5.+12.j])
# >>> vp.imag(1 + 1j)
# array(1.)
# @endcode
# @endpydoc
#
# @endif
def imag(val):
    val = nlcpy.asarray(val)
    return val.imag
## @}
