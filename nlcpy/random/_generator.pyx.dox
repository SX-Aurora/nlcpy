#
# * The source code in this file is based on the soure code of NumPy and CuPy.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# # NumPy License #
#
#     Copyright (c) 2005-2020, NumPy Developers.
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither the name of the NumPy Developers nor the names of any contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# # CuPy License #
#
#     Copyright (c) 2015 Preferred Infrastructure, Inc.
#     Copyright (c) 2015 Preferred Networks, Inc.
#
#     Permission is hereby granted, free of charge, to any person obtaining a copy
#     of this software and associated documentation files (the "Software"), to deal
#     in the Software without restriction, including without limitation the rights
#     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#     copies of the Software, and to permit persons to whom the Software is
#     furnished to do so, subject to the following conditions:
#
#     The above copyright notice and this permission notice shall be included in
#     all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#     THE SOFTWARE.
#

import numpy
import nlcpy
import sys


from nlcpy.random.generator import RandomState
from nlcpy.random.generator import _integers_types

_asl_seed_max = numpy.iinfo(numpy.uint32).max
_generator_supported_type = {'float32', 'float64'}


## 
# @if(lang_ja)
# @else
# @pydoc
# @brief SeedSequence mixes sources of entropy in a reproducible way to set
# the initial state for independent and very probably non-overlapping BitGenerators.
# @param entropy : <em>None or int or sequence[int], @b optional</em> @n
# The entropy for creating a SeedSequence.
# @note Best practice for achieving reproducible bit streams is to use the
# default None for the initial entropy, and then use SeedSequence.
# entropy to log/pickle the entropy for reproducibility:
# @code
# >>> import nlcpy as vp
# >>> sq1 = vp.random.SeedSequence()
# >>> sq1.entropy
# >>> array([3641776954])
# @endcode
# @endpydoc
# @endif
class SeedSequence:
    def __init__(self, entropy=None):
        if entropy is None:
            self.entropy = nlcpy.random.randint(0, _asl_seed_max)
        else:
            s = nlcpy.asarray(entropy)
            if s.dtype.name not in _integers_types:
                raise TypeError(
                    'SeedSequence expects int or sequence of ints for '
                    'entropy not {}' .format(entropy))
            if nlcpy.any(s < 0) or nlcpy.any(s > _asl_seed_max):
                raise ValueError('expected non-negative integer')
            self.entropy = s


## 
# @if(lang_ja)
# @else
# @pydoc
# @brief Base Class for generic BitGenerators, which provide a stream of
# random bits based on different algorithms. Must be overridden.
# @param seed : <em>None or int or array_like[ints], @b optional</em> @n
# A seed to initialize the BitGenerator. If None, then fresh, 
# unpredictable entropy will be pulled from the OS.
# @endpydoc
# @endif
class BitGenerator:
    def __init__(self, seed=None):
        if seed is None:
            seed = SeedSequence()
            self.entropy = seed.entropy
        elif hasattr(seed, "entropy"):
            self.entropy = seed.entropy
        else:
            s = SeedSequence(seed)
            self.entropy = s.entropy


## 
# @if(lang_ja)
# @else
# @pydoc
# @brief Container for the Mersenne Twister pseudo-random number generator.
# @details MT19937 is BitGenerator.
# @endpydoc
# @endif
class MT19937(BitGenerator):
    pass


## 
# @if(lang_ja)
# @else
# @pydoc
# @brief Container for the BitGenerators.
# @details <span class="pre">Generator</span> exposes a number of methods for generating random
# numbers drawn from a variety of probability distributions. In addition to
# the distribution-specific arguments, each method takes a keyword argument
# <em>size</em> that defaults to <span class="pre">None</span>. If <em>size</em> is <span class="pre">None</span>, then a single
# value is generated and returned. If <em>size</em> is an integer, then a 1-D
# array filled with generated values is returned. If <em>size</em> is a tuple,
# then an array with that shape is filled and returned.
# @n
# The function @ref _generator.default_rng "nlcpy.random.default_rng" will instantiate
# a <em>Generator</em> with default <em>BitGenerator</em>.
# @param bit_generator : <em>None or BitGenerator or int or array_like[ints], @b optional</em> @n
# BitGenerator to use as the core generator.
# @sa @li @ref default_rng "default_rng" : Recommended constructor for <em>Generator</em>.
# @endpydoc
# @endif
class Generator:
    def __init__(self, bit_generator):
        if not isinstance(bit_generator, BitGenerator):
            raise TypeError('Generator expects BitGenerator')
        if hasattr(bit_generator, "entropy"):
            self._rand = RandomState(bit_generator.entropy)
            self.bit_generator = bit_generator
        else:
            raise RuntimeError('Generator has not entropy')

    ## @if(lang_ja)
    # @else
    # @name Simple random data
    # @endif
    # @{
    ## @fn integers(self, low, high=None, size=None, dtype='int64', endpoint=False)
    # @rename _generator.Generator.integers integers nlcpy.random.Generator.integers
    # @ingroup ClassGenerator 
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns random integers from <em>low</em> (inclusive) to <em>high</em> (exclusive),
    # or if endpoint=True, <em>low</em> (inclusive) to <em>high</em> (inclusive). 
    # @details Replaces RandomState.randint (with endpoint=False) and
    #  RandomState.random_integers (with endpoint=True)
    # Returns random integers from the "discrete uniform" distribution of
    # the specified dtype. If <em>high</em> is None (the default), then results are
    # from 0 to <em>low</em>.
    # @param low : <em>int</em> @n
    # Lowest (signed) integer to be drawn from the distribution (unless
    # <span class="pre">high=None</span>, in which case this parameter is 0 and this value is
    # used for <em>high</em>).
    # @param high : <em>int, @b optional</em> @n
    # If provided, one above the largest (signed) integer to be drawn
    # from the distribution (see above for behavior if <span class="pre">high=None</span>).
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @param dtype : <em>str or dtype, @b optional</em> @n
    # Desired dtype of the result. All dtypes are determined by their
    # name, i.e., 'int64', 'int', etc, so byteorder is not available.
    # The default value is 'nlcpy.int64'. 
    # @param endpoint : <em>bool, @b optional</em> @n
    # If true, sample from the interval <span class="pre">[low, high]</span> instead of the
    # default <span class="pre">[low, high)</span>. Defaults to False.
    # @retval out : <em>@ref n-dimensional_array "ndarray" of ints</em> @n
    # <em>size</em>-shaped array of random integers from the appropriate
    # distribution.
    # @attention
    # @raise @em low is neither a scalar nor None : @em NotImplementedError occurs
    # @raise @em high is neither a scalar nor None : @em NotImplementedError occurs
    # @note When using broadcasting with uint64 dtypes, the maximum value (2**64)
    # cannot be represented as a standard integer type. The high array (or
    # low if high is None) must have object dtype, e.g., array([2**64]).
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> rng = vp.random.default_rng()
    # >>> rng.integers(2, size=10)
    # array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])  # random
    # >>> rng.integers(1, size=10)
    # array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    # 
    # #Generate a 2 x 4 array of ints between 0 and 4, inclusive:
    # >>> rng.integers(5, size=(2, 4))
    # array([[4, 0, 2, 1],
    #        [3, 2, 2, 0]])  # random
    # @endcode
    # @endpydoc
    # @endif
    def integers(self, low, high=None, size=None,
                 dtype='int64', endpoint=False):
        self._rand._is_number(low)
        if high is None:
            high = low
            low = 0
        else:
            self._rand._is_number(high)
        if endpoint == 1:
            high += 1
        return self._rand.randint(low, high, size=size, dtype=dtype)

    ## @fn random(self, size=None, dtype='d', out=None)
    # @rename _generator.Generator.random random nlcpy.random.Generator.random
    # @ingroup ClassGenerator 
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns random floats in the half-open interval <span class="pre">[0.0, 1.0)</span>.
    # @details Results are from the "continuous uniform" distribution over the
    # stated interval. To sample @f$Unif[a, b), b > a@f$ multiply
    # the output of %random by <em>(b-a)</em> and add <em>a</em>:@n
    #  (b - a) * %random() + a
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.  Default is None, in which case a
    # single value is returned.
    # @param dtype : <em>str or dtype, @b optional</em> @n
    # Desired dtype of the result, either 'd' (or 'float64') or 'f'
    # (or 'float32'). All dtypes are determined by their name. The
    # default value is 'd'.
    # @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
    # Alternative output array in which to place the result. If size is not None,@n
    # it must have the same shape as the provided size and must match the type of
    # the output values.
    # @retval out : <em>@ref n-dimensional_array "ndarray" of floats</em> @n
    # Array of random floats of shape <em>size</em>.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> rng = vp.random.default_rng()
    # >>> rng.random()
    # array([0.47108547995356098]) # random
    # >>> type(rng.random())
    # <class 'nlcpy.core.core.ndarray'>
    # >>> rng.random((5,))
    # array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
    # 
    # #Three-by-two array of random numbers from [-5, 0):
    # >>> 5 * rng.random((3, 2)) - 5
    # array([[-3.99149989, -0.52338984], # random
    #        [-2.99091858, -0.79479508],
    #        [-1.23204345, -1.75224494]])
    # @endcode
    # @endpydoc
    # @endif
    def random(self, size=None, dtype='d', out=None):
        dt = numpy.dtype(dtype)
        key = dt.name
        if key not in _generator_supported_type:
            raise TypeError('Unsupported dtype "{0}" for {1} '.
                            format(key, sys._getframe().f_code.co_name))
        if out is None:
            return self._rand._generate_random_uniform(size=size, dtype=dtype)
        else:
            self._outarg_check(dt, size, out)
            self._rand._generate_random_uniform_for_generator(
                size=size, out=out)

    ## @fn bytes(self, length)
    # @rename _generator.Generator.bytes bytes nlcpy.random.Generator.bytes
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns random bytes.
    # @param length : <em>int</em> @n
    # Number of random bytes.
    # @retval out : <em>str</em> @n
    # String of length <em>length</em>.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.default_rng().bytes(10)
    # b'\x9fW\xc5\x12\x95\xfd\xba\x0fd\xff' # random
    # @endcode
    # @endpydoc
    # @endif
    def bytes(self, length):
        return self._rand.bytes(length)

    ## @}
    #
    ## @if(lang_ja)
    # @else
    # @name Permutations
    # @endif
    # @{
    ## @fn shuffle(self, x)
    # @rename _generator.Generator.shuffle shuffle nlcpy.random.Generator.shuffle
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Modifies a sequence in-place by shuffling its contents.
    # @details This function only shuffles the array along the first axis of a
    # multi-dimensional array. The order of sub-arrays is changed but
    # their contents remains the same.
    # @param x : <em>array_like</em> @n
    # The array or list to be shuffled.
    # @retval None
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> rng = vp.random.default_rng()
    # >>> arr = vp.arange(10)
    # >>> rng.shuffle(arr)
    # >>> arr
    # array([7, 1, 5, 6, 0, 8, 4, 2, 9, 3]) # random
    #
    # # Multi-dimensional arrays are only shuffled along the first axis:
    #
    # >>> arr = vp.arange(9).reshape((3, 3))
    # >>> rng.shuffle(arr)
    # >>> arr
    # array([[3, 4, 5], # random
    #        [6, 7, 8],
    #        [0, 1, 2]])
    # @endcode
    # @endpydoc
    # @endif
    def shuffle(self, x):
        return self._rand.shuffle(x)

    ## @fn permutation(self, x)
    # @rename _generator.Generator.permutation permutation nlcpy.random.Generator.permutation
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Randomly permutes a sequence, or returns a permuted range.
    # @details If <em>x</em> is a multi-dimensional array, it is only shuffled along it
    # first index.
    # @param x : <em>int or array_like</em> @n
    # If <em>x</em> is an integer, randomly permute <span class="pre">vp.arange(x)</span>.
    # If <em>x</em> is an array, make a copy and shuffle the elements
    # randomly.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Permuted sequence or array range.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> rng = vp.random.default_rng()
    # >>> rng.permutation(10)
    # array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random
    #
    # >>> rng.permutation([1, 4, 9, 12, 15])
    # array([15,  1,  9,  4, 12]) # random
    #
    # >>> arr = vp.arange(9).reshape((3, 3))
    # >>> rng.permutation(arr)
    # array([[6, 7, 8], # random
    #        [0, 1, 2],
    #        [3, 4, 5]])
    # @endcode
    # @endpydoc
    # @endif
    def permutation(self, x):
        return self._rand.permutation(x)

    ## @}
    #
    ## @if(lang_ja)
    # @else
    # @name Distributions
    # @endif
    # @{
    ## @fn binomial(self, n, p, size=None)
    # @rename _generator.Generator.binomial binomial nlcpy.random.Generator.binomial
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a binomial distribution.
    # @details Samples are drawn from a binomial distribution with specified
    # parameters, n trials and p probability of success where
    # n an integer >= 0 and p is in the interval <span class="pre">[0,1]</span>. (n may be
    # input as a float, but it is truncated to an integer in use)
    # @param n : <em>int</em> @n
    # Parameter of the distribution, >= 0. Floats are also accepted,
    # but they will be truncated to integers.
    # @param p : <em>float</em> @n
    # Parameter of the distribution, >= 0 and <=1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized binomial distribution, where
    # each sample is equal to the number of successes over the n trials.
    # @attention
    # @raise @em n is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em p is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the binomial distribution is@n
    # @n
    #  @f$ P(N) = {n \choose N}p^N(1-p)^{n-N}, @f$ @n
    # @n
    # where @f$n@f$ is the number of trials, @f$p@f$ is the probability of success, and @f$N@f$ is the number of successes.@n
    # @n
    # When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n <=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead.@n 
    # For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> rng = vp.random.default_rng()
    # >>> n, p = 10, .5  # number of trials, probability of each trial
    # >>> s = rng.binomial(n, p, 1000)
    # # result of flipping a coin 10 times, tested 1000 times.
    #
    # # A real world example. A company drills 9 wild-cat oil exploration
    # # wells, each with an estimated probability of success of 0.1. All nine
    # # wells fail. What is the probability of that happening?
    #
    # # Let's do 20,000 trials of the model, and count the number that
    # # generate zero positive results.
    #
    # >>> sum(rng.binomial(9, 0.1, 20000) == 0)/20000.
    # # array(0.38625), or 38%.
    # @endcode
    # @endpydoc
    # @endif
    def binomial(self, n, p, size=None):
        return self._rand.binomial(n, p, size=size)

    ## @fn exponential(self, scale, size=None)
    # @rename _generator.Generator.exponential exponential nlcpy.random.Generator.exponential
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from an exponential distribution.
    # @details Its probability density function is@n
    # @n
    #  @f$ f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}), @f$ @n
    # @n
    # for <span class="pre">x > 0</span> and 0 elsewhere. @f$\beta@f$ is the scale parameter,
    # which is the inverse of the rate parameter @f$ \lambda = 1/\beta @f$.
    # @param scale : <em>float</em> @n
    # The scale parameter, @f$ \beta = 1/\lambda @f$. Must be
    # non-negative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized exponential distribution.
    # @attention
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @endpydoc
    # @endif
    def exponential(self, scale, size=None):
        return self._rand.exponential(scale, size=size)

    ## @fn gamma(self, shape, scale=1.0, size=None)
    # @rename _generator.Generator.gamma gamma nlcpy.random.Generator.gamma
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Gamma distribution.
    # @details Samples are drawn from a Gamma distribution with specified parameters,
    # <em>shape</em> (sometimes designated "k") and <em>scale</em> (sometimes designated
    # "theta"), where both parameters are > 0.
    # @param shape : <em>float</em> @n
    # The shape of the gamma distribution. Must be non-negative.
    # @param scale : <em>float, @b optional</em> @n
    # The scale of the gamma distribution. Must be non-negative.
    # Default is equal to 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized gamma distribution.
    # @attention
    # @raise @em shape is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Gamma distribution is@n
    # @n
    #  @f$ p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)}, @f$ @n
    # @n
    # where @f$k@f$ is the shape and @f$\theta@f$ the scale, and @f$\Gamma@f$ is the Gamma function.@n
    # @n
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
    # >>> s = vp.random.default_rng().gamma(shape, scale, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def gamma(self, shape, scale=1.0, size=None):
        return self._rand.gamma(shape, scale, size=size)

    ## @fn geometric(self, p, size=None)
    # @rename _generator.Generator.geometric geometric nlcpy.random.Generator.geometric
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a geometric distribution.
    # @details Bernoulli trials are experiments with one of two outcomes:
    # success or failure (an example of such an experiment is flipping
    # a coin).  The geometric distribution models the number of trials
    # that must be run in order to achieve success.@n
    # It is therefore supported on the positive integers, <span class="pre">k = 1, 2, ...</span>.@n
    # @n
    # The probability mass function of the geometric distribution is@n
    # @n
    #  @f$ f(k) = (1 - p)^{k - 1} p @f$ @n
    # @n
    # where <em>p</em> is the probability of success of an individual trial.
    # @param p : <em>float</em> @n
    # The probability of success of an individual trial.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized geometric distribution.
    # @attention
    # @raise @em p is neither a scalar nor None : @em NotImplementedError occurs.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw ten thousand values from the geometric distribution,
    # # with the probability of an individual success equal to 0.35:
    #
    # >>> z = vp.random.default_rng().geometric(p=0.35, size=10000)
    #
    # # How many trials succeeded after a single run?
    #
    # >>> (z.get() == 1).sum() / 10000.
    # 0.2235  # random
    # @endcode
    # @endpydoc
    # @endif
    def geometric(self, p, size=None):
        return self._rand.geometric(p, size=size)

    ## @fn gumbel(self, loc=0.0, scale=1.0, size=None)
    # @rename _generator.Generator.gumbel gumbel nlcpy.random.Generator.gumbel
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Gumbel distribution.
    # @details Draws samples from a Gumbel distribution with specified location and
    # scale.  For more information on the Gumbel distribution, see
    # Notes and References below.
    # @param loc : <em>float, @b optional</em> @n
    # The location of the mode of the distribution. Default is 0.
    # @param scale : <em>float, @b optional</em> @n
    # The scale parameter of the distribution. Default is 1. Must be non-negative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized Gumbel distribution.
    # @sa @li @ref weibull "weibull" : Draws samples from a Weibull distribution.
    # @attention
    # @raise @em loc is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Gumbel distribution is@n
    #  @n
    #  @f$ p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/ \beta}}, @f$ @n
    # @n
    # where @f$\mu@f$ is the mode, a location parameter, and
    #  @f$\beta@f$ is the scale parameter.@n
    # @n
    # The function has a mean of @f$ \mu + 0.57721\beta @f$ and a variance
    # of @f$ \frac{\pi^2}{6}\beta^2 @f$.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> rng = vp.random.default_rng()
    # >>> mu, beta = 0, 0.1 # location and scale
    # >>> s = rng.gumbel(mu, beta, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def gumbel(self, loc=0.0, scale=1.0, size=None):
        return self._rand.gumbel(loc, scale, size=size)

    ## @fn logistic(self, loc=0.0, scale=1.0, size=None)
    # @rename _generator.Generator.logistic logistic nlcpy.random.Generator.logistic
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a logistic distribution.
    # @details Samples are drawn from a logistic distribution with specified
    # parameters, <em>loc</em> (location or mean, also median), and <em>scale</em> (>0).
    # @param loc : <em>float, @b optional</em> @n
    # Parameter of the distribution. Default is 0.
    # @param scale : <em>float, @b optional</em> @n
    # Parameter of the distribution. Must be non-negative.
    # Default is 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized logistic distribution.
    # @attention
    # @raise @em loc is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Logistic distribution is@n
    # @n
    #  @f$ P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2}, @f$ @n
    # @n
    # where @f$\mu@f$ = location and @f$s@f$ = scale.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> loc, scale = 10, 1
    # >>> s = vp.random.default_rng().logistic(loc, scale, 10000)
    # @endcode
    # @endpydoc
    # @endif
    def logistic(self, loc=0.0, scale=1.0, size=None):
        return self._rand.logistic(loc, scale, size=size)

    ## @fn lognormal(self, mean=0.0, sigma=1.0, size=None)
    # @rename _generator.Generator.lognormal lognormal nlcpy.random.Generator.lognormal
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a log-normal distribution.
    # @details Draws samples from a log-normal distribution with specified mean,
    # standard deviation, and array shape.  Note that the mean and standard
    # deviation are not the values for the distribution itself, but of the
    # underlying normal distribution it is derived from.
    # @param mean : <em>float, @b optional</em> @n
    # Mean value of the underlying normal distribution. Default is 0.
    # @param sigma : <em>float, @b optional</em> @n
    # Standard deviation of the underlying normal distribution. Must be
    # non-negative. Default is 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized log-normal distribution.
    # @attention
    # @raise @em mean is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em sigma is neither a scalar nor None : @em NotImplementedError occurs.
    # @note A variable <em>x</em> has a log-normal distribution if <em>log(x)</em> is normally
    # distributed.  The probability density function for the log-normal
    # distribution is:@n
    # @n
    #  @f$ p(x) = \frac{1}{\sigma x \sqrt{2\pi}}e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})} @f$ @n
    # @n
    # where @f$\mu@f$ is the mean and @f$\sigma@f$ is the standard
    # deviation of the normally distributed logarithm of the variable.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> rng = vp.random.default_rng()
    # >>> mu, sigma = 3., 1. # mean and standard deviation
    # >>> s = rng.lognormal(mu, sigma, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def lognormal(self, mean=0.0, sigma=1.0, size=None):
        return self._rand.lognormal(mean, sigma, size=size)

    ## @fn normal(self, loc=0.0, scale=1.0, size=None)
    # @rename _generator.Generator.normal normal nlcpy.random.Generator.normal
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws random samples from a normal (Gaussian) distribution.
    # @details The probability density function of the normal distribution, first
    # derived by De Moivre and 200 years later by both Gauss and Laplace
    # independently, is often called the bell curve because of
    # its characteristic shape (see the example below).@n
    # @n
    # The normal distributions occurs often in nature.  For example, it
    # describes the commonly occurring distribution of samples influenced
    # by a large number of tiny, random disturbances, each with its own
    # unique distribution.
    # @param loc : <em>float</em> @n
    # Mean ("centre") of the distribution.
    # @param scale : <em>float</em> @n
    # Standard deviation (spread or "width") of the distribution. Must be
    # non-negative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized normal distribution.
    # @attention
    # @raise @em loc is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Gaussian distribution is@n
    # @n
    #  @f$ p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} }, @f$ @n
    # @n
    # where @f$\mu@f$ is the mean and @f$\sigma@f$ the standard@n
    # deviation. The square of the standard deviation, @f$\sigma^2@f$,
    # is called the variance.@n
    # @n
    # The function has its peak at the mean, and its "spread" increases with
    # the standard deviation (the function reaches 0.607 times its maximum at
    # @f$x + \sigma@f$ and @f$x - \sigma@f$).  This implies that
    # <em>numpy.random.normal</em> is more likely to return samples lying close to
    # the mean, rather than those far away.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> mu, sigma = 0, 0.1 # mean and standard deviation
    # >>> s = vp.random.default_rng().normal(mu, sigma, 1000)
    #
    # # Verify the mean and the variance:
    #
    # >>> abs(mu - vp.mean(s))
    # array(0.00206415)  # may vary
    #
    # >>> abs(sigma - vp.std(s, ddof=1))
    # array(0.00133596)  # may vary
    #
    # # Two-by-four array of samples from N(3, 6.25):
    #
    # >>> vp.random.default_rng().normal(3, 2.5, size=(2, 4))
    # array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
    #        [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
    # @endcode
    # @endpydoc
    # @endif
    def normal(self, loc=0.0, scale=1.0, size=None):
        return self._rand.normal(loc=loc, scale=scale, size=size)

    ## @fn poisson(self, lam=1.0, size=None)
    # @rename _generator.Generator.poisson poisson nlcpy.random.Generator.poisson
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Poisson distribution.
    # @details The Poisson distribution is the limit of the binomial distribution
    # for large N.
    # @param lam : <em>float</em> @n
    # Expectation of interval, must be >= 0. A sequence of expectation
    # intervals must be broadcastable over the requested size.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized Poisson distribution.
    # @attention
    # @raise @em lam is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The Poisson distribution@n
    # @n
    #  @f$ f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!} @f$ @n
    # @n
    # For events with an expected separation @f$\lambda@f$ the Poisson
    # distribution @f$f(k; \lambda)@f$ describes the probability of
    #  @f$k@f$ events occurring within the observed
    # interval @f$\lambda@f$.@n
    # @n
    # Because the output is limited to the range of the C int64 type, a
    # ValueError is raised when <em>lam</em> is within 10 sigma of the maximum
    # representable value.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> rng = vp.random.default_rng()
    # >>> s = rng.poisson(5, 10000)
    # @endcode
    # @endpydoc
    # @endif
    def poisson(self, lam=1.0, size=None):
        return self._rand.poisson(lam, size=size)

    ## @fn standard_cauchy(self, size=None)
    # @rename _generator.Generator.standard_cauchy standard_cauchy nlcpy.random.Generator.standard_cauchy
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard Cauchy distribution with mode = 0.
    # @details Also known as the Lorentz distribution.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval samples : <em>@ref n-dimensional_array "ndarray"</em> @n
    # The drawn samples.
    # @note The probability density function for the full Cauchy distribution is@n
    # @n
    #  @f$ P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+(\frac{x-x_0}{\gamma})^2 \bigr] } @f$ @n
    # @n
    # and the Standard Cauchy distribution just sets @f$ x_0=0 @f$ and
    # @f$ \gamma=1 @f$
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples and plot the distribution:
    #
    # >>> s = vp.random.default_rng().standard_cauchy(1000000)
    # @endcode
    # @endpydoc
    # @endif
    def standard_cauchy(self, size=None):
        return self._rand.standard_cauchy(size=size)

    ## @fn standard_exponential(self, size=None, dtype='d', method=None, out=None) 
    # @rename _generator.Generator.standard_exponential standard_exponential nlcpy.random.Generator.standard_exponential
    # @ingroup ClassGenerator 
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard exponential distribution.
    # @details %standard_exponential is identical to the exponential distribution
    # with a scale parameter of 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @param dtype : <em>dtype, @b optional</em> @n
    # Desired dtype of the result, either 'd' (or 'float64') or 'f'
    # (or 'float32'). All dtypes are determined by their name. The
    # default value is 'd'.
    # @param method : <em>str, @b optional</em> @n
    # Function by this argument is not implemented.
    # @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
    # Alternative output array in which to place the result. If size is not None,
    # it must have the same shape as the provided size and must match the type of
    # the output values.
    # @retval out : <em>@ref n-dimensional_array "ndarray" </em> @n
    # Drawn samples.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> n = vp.random.default_rng().standard_exponential((3, 8000))
    # @endcode
    # @endpydoc
    # @endif
    def standard_exponential(
            self, size=None, dtype='d', method=None, out=None):
        if method is not None:
            raise NotImplementedError('method is None only')
        dt = numpy.dtype(dtype)
        key = dt.name
        if key not in _generator_supported_type:
            raise TypeError('Unsupported dtype "{0}" for {1} '.
                            format(key, sys._getframe().f_code.co_name))

        if out is None:
            return self._rand._generate_random_exponential(
                1.0, size=size, dtype=float)
        else:
            self._outarg_check(dt, size, out)
            self._rand._generate_random_exponential_for_generator(
                size=out.size, out=out)

    ## @fn standard_gamma(self, shape, size=None, dtype='d', out=None)
    # @rename _generator.Generator.standard_gamma standard_gamma nlcpy.random.Generator.standard_gamma
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard Gamma distribution.
    # @details Samples are drawn from a Gamma distribution with specified parameters,@n
    # shape (sometimes designated "k") and scale=1.
    # @param shape : <em>float</em> @n
    # Parameter, must be non-negative.    
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @param dtype : <em>str or dtype, @b optional</em> @n
    # Desired dtype of the result, either 'd' (or 'float64') or 'f'
    # (or 'float32'). All dtypes are determined by their name. The
    # default value is 'd'.
    # @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
    # Alternative output array in which to place the result. If size is
    # not None, it must have the same shape as the provided size and
    # must match the type of the output values.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized standard gamma distribution.
    # @attention
    # @raise @em shape is neither a scalar nor None : @em NotImplementedError occurs
    # @note The probability density for the Gamma distribution is
    # @n
    #  @f$ p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)}, @f$
    # @n
    # where @f$k@f$ is the shape and @f$\theta@f$ the scale,
    # and @f$\Gamma@f$ is the Gamma function.@n
    # The Gamma distribution is often used to model the times to failure of
    # electronic components, and arises naturally in processes for which the
    # waiting times between Poisson distributed events are relevant.
    # @par Example
    # @code
    # # Draw samples from the distribution.
    # >>> import nlcpy as vp
    # >>> shape, scale = 2., 1. # mean and width
    # >>> s = vp.random.default_rng().standard_gamma(shape, 1000000)
    #
    # >>> import matplotlib.pyplot as plt
    # >>> import scipy.special as sps # doctest: +SKIP
    # >>> count, bins, ignored = plt.hist(s, 50, density=True)
    # >>> y = bins**(shape-1) * ((vp.exp(-bins/scale))/ # doctest: +SKIP
    # ... (sps.gamma(shape) * scale**shape))
    # >>> plt.plot(bins, y, linewidth=2, color='r') # doctest: +SKIP
    # >>> plt.show()
    # @endcode
    # @endpydoc
    # @image html gamma_distribution.png
    # @endif
    def standard_gamma(self, shape, size=None, dtype='d', out=None):
        self._rand._is_number(shape)
        if shape < 0:
            raise ValueError('shape < 0')

        dt = numpy.dtype(dtype)
        key = dt.name
        if key not in _generator_supported_type:
            raise TypeError('Unsupported dtype "{0}" for {1} '.
                            format(key, sys._getframe().f_code.co_name))

        if out is None:
            return self._rand._generate_random_gamma(
                shape, scale=1.0, size=size, dtype=dtype)
        else:
            self._outarg_check(dt, size, out)
            self._rand._generate_random_gamma_for_generator(
                shape, scale=1.0, size=out.size, out=out)

    ## @fn standard_normal(self, size=None, dtype='d' ,out=None)
    # @rename _generator.Generator.standard_normal standard_normal nlcpy.random.Generator.standard_normal
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard Normal distribution (mean=0, stdev=1).
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @param dtype : <em>str or dtype, @b optional</em> @n
    # Desired dtype of the result, either 'd' (or 'float64') or 'f'
    # (or 'float32'). All dtypes are determined by their name. The
    # default value is 'd'.
    # @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n 
    # Alternative output array in which to place the result. If size is not None,
    # it must have the same shape as the provided size and must match the type of
    # the output values.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # A floating-point array of shape <span class="pre">size</span> of drawn samples,
    # if <span class="pre">size</span> was not specified.
    # @sa @li @ref normal "normal" : Draws %random samples from a %normal (Gaussian) distribution.
    # @note For random samples from @f$N(\mu, \sigma^2)@f$, use one of:@n
    # mu + sigma * gen.standard_normal(size=...)@n
    # gen.normal(mu, sigma, size=...)
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> rng = vp.random.default_rng()
    # >>> rng.standard_normal()
    # array([2.1923875335537315]) # random
    # 
    # >>> s = rng.standard_normal(8000)
    # >>> s
    # array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
    #        -0.38672696, -0.4685006 ])                                # random
    # >>> s.shape
    # (8000,)
    # >>> s = rng.standard_normal(size=(3, 4, 2))
    # >>> s.shape
    # (3, 4, 2)
    # 
    # #Two-by-four array of samples from :math:`N(3, 6.25)`:
    # >>> 3 + 2.5 * rng.standard_normal(size=(2, 4))
    # array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
    #        [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
    # @endcode
    # @endpydoc
    # @endif
    def standard_normal(self, size=None, dtype='d', out=None):
        dt = numpy.dtype(dtype)
        key = dt.name
        if key not in _generator_supported_type:
            raise TypeError('Unsupported dtype "{0}" for {1} '.
                            format(key, sys._getframe().f_code.co_name))
        if out is None:
            return self._rand._generate_random_normal(
                0.0, scale=1.0, size=size, dtype=float)
        else:
            self._outarg_check(dt, size, out)
            self._rand._generate_random_normal_for_generator(
                size=out.size, out=out)

    ## @fn uniform(self, low=0.0, high=1.0, size=None)
    # @rename _generator.Generator.uniform uniform nlcpy.random.Generator.uniform
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a uniform distribution.
    # @details Samples are uniformly distributed over the half-open interval
    # <span class="pre">[low, high)</span> (includes low, but excludes high).  In other words,@n
    # any value within the given interval is equally likely to be drawn
    # by uniform.
    # @param low : <em>float, @b optional</em> @n
    # Lower boundary of the output interval.  All values generated will be
    # greater than or equal to low.  The default value is 0.
    # @param high : <em>float</em> @n
    # Upper boundary of the output interval.  All values generated will be
    # less than high.  The default value is 1.0.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized uniform distribution.
    # @sa @li @ref integers "integers" : Returns %random %integers from <em>low</em> (inclusive) to <em>high</em> (exclusive), or if endpoint=True, <em>low</em> (inclusive) to <em>high</em> (inclusive).
    # @sa @li @ref random "random" : Returns %random floats in the half-open interval <span class="pre">[0.0, 1.0)</span>.
    # @attention
    # @raise @em low is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em high is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density function of the uniform distribution is@n
    # @n
    #  @f$ p(x) = \frac{1}{b - a} @f$ @n
    # @n
    # anywhere within the interval <span class="pre">[a, b)</span>, and zero elsewhere.@n
    # @n
    # When <span class="pre">high</span> == <span class="pre">low</span>, values of <span class="pre">low</span> will be returned.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> s = vp.random.default_rng().uniform(-1,0,1000)
    #
    # # All values are within the given interval:
    #
    # >>> vp.all(s >= -1)
    # array(True)
    # >>> vp.all(s < 0)
    # array(True)
    # @endcode
    # @endpydoc
    # @endif
    def uniform(self, low=0.0, high=1.0, size=None):
        return self._rand.uniform(low, high, size=size)

    ## @fn weibull(self, a, size=None)
    # @rename _generator.Generator.weibull weibull nlcpy.random.Generator.weibull
    # @ingroup ClassGenerator
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Weibull distribution.
    # @details Draws samples from a 1-parameter Weibull distribution with the given
    # shape parameter <em>a</em>.@n
    # @n
    #  @f$ X = (-ln(U))^{1/a} @f$ @n
    # @n
    # Here, U is drawn from the uniform distribution over <span class="pre">(0,1]</span>.@n
    # @n
    # The more common 2-parameter Weibull, including a scale parameter
    # @f$\lambda@f$ is just @f$ X = \lambda(-ln(U))^{1/a} @f$.
    # @param a : <em>float</em> @n
    # Shape parameter of the distribution.  Must be nonnegative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized Weibull distribution.
    # @sa @li @ref gumbel "gumbel" : Draws samples from a Gumbel distribution.
    # @attention
    # @raise @em a is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Weibull distribution is@n
    # @n
    #  @f$ p(x) = \frac{a}{\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a}, @f$ @n
    # @n
    # where @f$a@f$ is the shape and @f$\lambda@f$ the scale.@n
    # @n
    # The function has its peak (the mode) at@n
    #  @f$ \lambda(\frac{a-1}{a})^{1/a}. @f$ @n
    # @n
    # When <span class="pre">a = 1</span>, the Weibull distribution reduces to the exponential
    # distribution.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> rng = vp.random.default_rng()
    # >>> a = 5. # shape
    # >>> s = rng.weibull(a, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def weibull(self, a, size=None):
        return self._rand.weibull(a, size=size)

    ## @}
    #
    def _outarg_check(self, dt, size, nda):
        if not isinstance(nda, nlcpy.core.core.ndarray):
            raise ValueError(
                "Supplied output array is not contiguous, writable or aligned.")

        if numpy.dtype(nda.dtype) != dt:
            raise TypeError(
                "Supplied output array has the wrong type,"
                " Expected {0}, got {1}".format(
                    dt, nda.dtype.name))
        if size is not None:
            if nda.shape != size and nda.shape != (size,):
                raise ValueError(
                    "size must match out.shape when used together")


# lazy initialize (To avoid a long execution time when import )
_default_rng = None


## @fn default_rng(seed=None)
# @rename _generator.default_rng default_rng nlcpy.random.default_rng
# @ingroup ClassGenerator
# @if(lang_ja)
# @else
# @pydoc
# @brief Constructs a new nlcpy.random.Generator with the default %BitGenerator (%MT19937).
# @param seed : <em>None or int or array_like[ints], @b optional</em>
# @note When <em>seed</em> is omitted or <span class="pre">None</span>, a new <em>%BitGenerator</em> and <em>%Generator</em> will
# be instantiated each time.@n
# This function does not manage a default global instance.
# @endpydoc
# @endif
def default_rng(seed=None):
    global _default_rng
    if _default_rng is None or seed is not None:
        _default_rng = Generator(MT19937(seed))

    return _default_rng
