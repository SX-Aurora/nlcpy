#
# * The source code in this file is based on the soure code of NumPy and CuPy.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# # NumPy License #
#
#     Copyright (c) 2005-2020, NumPy Developers.
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither the name of the NumPy Developers nor the names of any contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# # CuPy License #
#
#     Copyright (c) 2015 Preferred Infrastructure, Inc.
#     Copyright (c) 2015 Preferred Networks, Inc.
#
#     Permission is hereby granted, free of charge, to any person obtaining a copy
#     of this software and associated documentation files (the "Software"), to deal
#     in the Software without restriction, including without limitation the rights
#     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#     copies of the Software, and to permit persons to whom the Software is
#     furnished to do so, subject to the following conditions:
#
#     The above copyright notice and this permission notice shall be included in
#     all copies or substantial portions of the Software.
#
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#     THE SOFTWARE.
#

from libgenerator cimport *
import numbers
import copy
import numpy
import nlcpy

from nlcpy import veo

from nlcpy import ndarray
from nlcpy import asarray
from nlcpy import array
from nlcpy import empty
from nlcpy import any
from nlcpy import nan
from nlcpy.request import request

# change in the future
from numpy import broadcast

_integers_types = {
    'bool',
    'int',
    'int8',
    'int16',
    'int32',
    'int64',
    'uint8',
    'uint16',
    'uint32',
    'uint64'}
_unsigned_integers_types = {'bool', 'uint8', 'uint16', 'uint32', 'uint64'}


def _get_rand():
    global _rand
    if _rand is None:
        _rand = RandomState()
    return _rand


## @fn get_state()
# @rename generator.get_state get_state nlcpy.random.get_state
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns a ndarray representing the internal state of the generator.
# @details For more details, see set_state.
# @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
# A ndarray containg seeds to be required for generating random numbers.
# @note set_state and get_state are not needed to work with any of the@n
# random distributions in NLCPy.
# @endpydoc
# @endif
def get_state():
    rs = _get_rand()
    return rs.get_state()


## @fn set_state(state)
# @rename generator.set_state set_state nlcpy.random.set_state
# @if(lang_ja)
# @else
# @pydoc
# @brief Sets the internal state of the generator from a ndarray.
# @details For use if one has reason to manually (re-)set the internal state of@n
# the bit generator used by the RandomState instance. 
# @param state : <em>ndarrayi</em> @n
# The <em>state</em> ndarray has the following items:@n
# @n
# 1. seeds for ASL Unified Interface.
# @retval out : <em>None</em>
# Returns 'None' on success.
# @sa @li @ref get_state "get_state" : Returns a tuple representing the internal state of the generator.
# @note set_state and get_state are not needed to work with any of the@n
# random distributions in NLCPy.
# @endpydoc
# @endif
def set_state(state):
    rs = _get_rand()
    rs.set_state(state)
    return


## @fn seed(seed=None)
# @rename generator.seed seed nlcpy.random.seed
# @if(lang_ja)
# @else
# @pydoc
# @brief Reseeds a MT19937 BitGenerator
# @par Example
# @code
# >>> from nlcpy.random import MT19937
# >>> from nlcpy.random import RandomState, SeedSequence
# >>> rs = RandomState(MT19937(SeedSequence(123456789)))
# # Later, you want to restart the stream
# >>> rs = RandomState(MT19937(SeedSequence(987654321)))
# @endcode
# @endpydoc
# @endif
def seed(seed=None):
    rs = _get_rand()
    rs.seed(seed)
    return


##  
# @if(lang_ja)
# @else
# @pydoc
# @brief Container for the slow Mersenne Twister pseudo-random number generator.
# @details <em>RandomState</em> and <em>Generator</em> expose a number of methods for generating
# random numbers drawn from a variety of probability distributions.@n
# In addition to the distribution-specific arguments, each method takes a
# keyword argument <em>size</em> that defaults to <span class="pre">None</span>. If <em>size</em> is <span class="pre">None</span>,@n
# then a single value is generated and returned. If <em>size</em> is an integer,@n
# then a 1-D array filled with generated values is returned. @n
# If <em>size</em> is a tuple, then an array with that shape is filled and returned.
# @param seed : <em>None or int or array_like, @b optional</em> @n
# Random seed used to initialize the pseudo-random number generator or
# an instantized BitGenerator.  If an integer or array, used as a seed for
# the MT19937 BitGenerator. Values can be any integer between 0 and
# 2**32 - 1 inclusive, an array (or other sequence) of such integers,
# or <span class="pre">None</span> (the default).
# @endpydoc
# @endif
class RandomState():
    _asl_seed_max = numpy.iinfo(numpy.uint32).max

    def __init__(self, seed=None):
        self.seed(seed)

    ## @if(lang_ja)
    # @else
    # @name Seeding and State
    # @endif
    # @{
    ## @fn get_state(self, legacy=True)
    # @rename generator.RandomState.get_state get_state nlcpy.random.RandomState.get_state
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns a ndarray representing the internal state of the generator.
    # @details For more details, see set_state.
    # @param legacy :<em> bool</em> @n
    # Not used in NLCPy.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # A ndarray containg seeds to be required for generating random numbers.
    # @sa @li @ref set_state "set_state" : Sets the internal state of the %generator from a ndarray.
    # @note set_state and get_state are not needed to work with any of the@n
    # random distributions in NLCPy.
    # @endpydoc
    # @endif
    def get_state(self, legacy=True):
        return self._asl_get_state()

    ## @fn set_state(self, state)
    # @rename generator.RandomState.set_state set_state nlcpy.random.RandomState.set_state
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Sets the internal state of the generator from a ndarray.
    # @details For use if one has reason to manually (re-)set the internal state of
    # the bit generator used by the %RandomState instance.
    # @param state : <em>@ref n-dimensional_array "ndarray"</em> @n
    # A ndarray containg seeds to be required for generating random numbers. 
    # @retval out : <em>None</em> @n
    # Returns 'None' on success.
    # @sa @li @ref get_state "get_state" : Returns a tuple representing the internal state of the %generator.
    # @note set_state and get_state are not needed to work with any of the@n
    # random distributions in NLCPy.
    # @endpydoc
    # @endif
    def set_state(self, state):
        if not isinstance(state, ndarray):
            raise TypeError('state is not valid')
        else:
            if not numpy.dtype(state.dtype).name == 'uint32':
                raise TypeError(
                    'Unsupported dtype {} for set_state' .format(
                        numpy.dtype(
                            state.dtype).name))
            self._asl_set_state(state)

    def _get_seed(self):
        return self._ve_seed.get().tolist()

    ## @}
    #
    ## @if(lang_ja)
    # @else
    # @name Simple random data
    # @endif
    # @{
    ## @fn tomaxint(self, size)
    # @rename generator.RandomState.tomaxint tomaxint nlcpy.random.RandomState.tomaxint
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Random integers between 0 and <span class="pre">numpy.iinfo(numpy.int).max</span>, inclusive.
    # @details Return a sample of uniformly distributed random integers in the interval
    # <span class="pre">[0, numpy.iinfo(numpy.int).max]</span>. 
    # The nlcpy.int64/nlcpy.int32 type translates to the C long integer type, 
    # which is @c int64_t in NLCPy.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples, with shape <em>size</em>.
    # @par Example
    # @code
    # >>> import numpy as np
    # >>> import nlcpy as vp
    # >>> rs = vp.random.RandomState() # need a RandomState object
    # >>> rs.tomaxint((2,2,2))
    # array([[[1170048599, 1600360186], # random
    #         [ 739731006, 1947757578]],
    #       [[1871712945,  752307660],
    #        [1601631370, 1479324245]]])
    # >>> rs.tomaxint((2,2,2)) <np.iinfo(np.int).max
    # array([[[ True,  True],
    #         [ True,  True]],
    # 
    #        [[ True,  True],
    #         [ True,  True]]])
    # @endcode
    # @endpydoc
    # @endif
    def tomaxint(self, size):
        return self.randint(0, 2**31 - 1, size=size)

    ## @fn rand(self, size)
    # @rename generator.RandomState.rand rand nlcpy.random.RandomState.rand
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Random values in a given shape.
    # @details Create an array of the given shape and populate it with
    # random samples from a uniform distribution
    # over <span class="pre">[0, 1)</span>.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # The dimensions of the returned array, must be non-negative.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Random values, with shape @em size.
    # @sa @li @ref random "random" : Returns %random floats in the half-open interval <span class="pre">[0.0, 1.0)</span>.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.rand(3,2)
    # array([[ 0.14022471,  0.96360618],  # random
    #        [ 0.37601032,  0.25528411],  # random
    #        [ 0.49313049,  0.94909878]]) # random
    # @endcode
    # @endpydoc
    # @endif
    def rand(self, size):
        return self.random_sample(size)

    ## @fn randn(self, size)
    # @rename generator.RandomState.randn randn nlcpy.random.RandomState.randn
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns a sample (or samples) from the "standard normal" distribution.
    # @details If positive int_like arguments are provided, randn generates an array
    # of shape <span class="pre">(d0, d1, ..., dn)</span>, filled
    # with random floats sampled from a univariate "normal" (Gaussian)
    # distribution of mean 0 and variance 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # The dimensions of the returned array, must be non-negative.
    # @retval Z : <em>@ref n-dimensional_array "ndarray"</em> @n
    # A <span class="pre">(d0, d1, ..., dn)</span>-shaped array of floating-point samples from
    # the standard normal distribution, or a single such float if
    # no parameters were supplied.
    # @sa @li standard_normal : Draws samples from a standard Normal distribution (mean=0, stdev=1). "standard_normal"
    # @sa @li normal : Draws %random samples from a %normal (Gaussian) distribution.
    # @note For random samples from @f$ N(\mu, \sigma^2),@f$ use:@n
    # <span class="pre">sigma * vp.random.randn(...) + mu</span>
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.randn()
    # array([0.54214143])  # random
    # # Two-by-four array of samples from N(3, 6.25):
    # >>> 3 + 2.5 * vp.random.randn(2, 4)
    # array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
    #        [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
    # @endcode
    # @endpydoc
    # @endif
    def randn(self, size):
        return self.normal(0.0, 1.0, size=size)

    ## @fn randint(self, low, high=None, size=None, dtype=int)
    # @rename generator.RandomState.randint randint nlcpy.random.RandomState.randint
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns random integers from <em>low</em> (inclusive) to <em>high</em> (exclusive).
    # @details Returns random integers from the "discrete uniform" distribution of
    # the specified dtype in the "half-open" interval <span class="pre">[<em>low</em>, <em>high</em>)</span>. If
    # <em>high</em> is None (the default), then results are from <span class="pre">[0, <em>low</em>)</span>.
    # @param low : <em>int</em> @n
    # array_like of ints is not implemented.
    # Lowest (signed) integers to be drawn from the distribution (unless
    # <span class="pre">high=None</span>, in which case this parameter is one above the
    # *highest* such integer).
    # @param  high : <em>int , @b optional</em> @n
    # array_like of ints is not implemented.
    # If provided, one above the largest (signed) integer to be drawn
    # from the distribution (see above for behavior if <span class="pre">high=None</span>).
    # @param size : <em>int or ints, @b optional</em> @n
    # @param dtype : <em>dtype, @b optional</em> @n
    # Desired dtype of the result. All dtypes are determined by their
    # name, i.e., 'int64', 'int', etc, so byteorder is not available
    # and a specific precision may have different C types depending
    # on the platform.
    # @retval out : <em>@ref n-dimensional_array "ndarray" of ints</em> @n
    # <em>size</em>-shaped array of random integers from the appropriate
    # distribution, or a single such random int if <em>size</em> not provided.
    # @sa @li random_integers : Random integers of type nlcpy.int64/nlcpy.int32 between low and high, inclusive. "random.random_integers"
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.randint(2, size=10)
    # array([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random
    # >>> vp.random.randint(1, size=10)
    # array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
    #
    # # Generate a 2 x 4 array of ints between 0 and 4, inclusive:
    #
    # >>> vp.random.randint(5, size=(2, 4))
    # array([[4, 0, 2, 1], # random
    #        [3, 2, 2, 0]])
    #
    # # Generate a 1 x 3 array with 3 different upper bounds
    #
    # >>> vp.random.randint(5, size=(2, 4))
    # array([[4, 0, 2, 1], # random
    #        [3, 2, 2, 0]])
    # @endcode
    # @endpydoc
    # @endif
    def randint(self, low, high=None, size=None, dtype=int):

        # AttributeError: module 'nlcpy' has no attribute 'dtype'
        dt = numpy.dtype(dtype)
        key = dt.name
        if key not in _integers_types:
            raise TypeError(
                'Unsupported dtype {} for randint' .format(
                    numpy.dtype(dtype).name))

        if high is None:
            lo = 0
            hi = low
        else:
            lo = low
            hi = high
        if lo >= hi:
            raise ValueError('low >= high')

        if key == 'bool':
            if lo < 0:
                raise ValueError(
                    'low is out of bounds for {}'.format(
                        numpy.dtype(dtype).name))
            if hi > 2:
                raise ValueError(
                    'high is out of bounds for {}'.format(
                        numpy.dtype(dtype).name))
        else:
            if lo < numpy.iinfo(dtype).min:
                raise ValueError(
                    'low is out of bounds for {}'.format(
                        numpy.dtype(dtype).name))
            if hi > numpy.iinfo(dtype).max + 1:
                raise ValueError(
                    'high is out of bounds for {}'.format(
                        numpy.dtype(dtype).name))

        return self._generate_random_integers(
            lo, high=hi, size=size, dtype=dtype)

    ## @fn ranf(self, size)
    # @rename generator.RandomState.ranf ranf nlcpy.random.RandomState.ranf
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief This is an alias of random_sample. See random_sample for the complete
    # documentation.
    # @endpydoc
    # @endif
    def ranf(self, size):
        return self.random_sample(size)

    ## @fn sample(self, size)
    # @rename generator.RandomState.sample sample nlcpy.random.RandomState.sample
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief This is an alias of random_sample. See random_sample for the complete
    # documentation.
    # @endpydoc
    # @endif
    def sample(self, size):
        return self.random_sample(size)

    ## @fn random(self, size=None)
    # @rename generator.RandomState.random random nlcpy.random.RandomState.random
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns random floats in the half-open interval <span class="pre">[0.0, 1.0)</span>. 
    # Alias for random_sample to ease forward-porting to the new random API.
    # @endpydoc
    # @endif
    def random(self, size=None):
        return self.random_sample(size)

    ## @fn random_integers(self, low, high=None, size=None)
    # @rename generator.RandomState.random_integers random_integers nlcpy.random.RandomState.random_integers
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Random integers of type nlcpy.int64/nlcpy.int32 between <em>low</em> and <em>high</em>, inclusive.
    # @details Return random integers of type nlcpy.int64/nlcpy.int32 from the "discrete uniform"
    # distribution in the closed interval <span class="pre">[<em>low</em>, <em>high</em>]</span>.  If <em>high</em> is
    # None (the default), then results are from <span class="pre">[1, <em>low</em>]</span>.
    # @param low : <em>int</em> @n
    # Lowest (signed) integer to be drawn from the distribution (unless
    # <span class="pre">high=None</span>, in which case this parameter is the *highest* such
    # integer).
    # @param high : <em>int, @b optional</em> @n
    # If provided, the largest (signed) integer to be drawn from the
    # distribution (see above for behavior if <span class="pre">high=None</span>).
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray" of ints</em> @n
    # <em>size</em>-shaped array of random integers from the appropriate
    # distribution.
    # @sa @li randint :  Returns %random integers from low (inclusive) to high (exclusive). "randint"
    # @note To sample from N evenly spaced floating-point numbers between a and b,@n
    # use:@n
    #  <span class="pre">a + (b - a) * (vp.random.random_integers(N) - 1) / (N - 1.)</span>
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.random_integers(5)
    # array([2]) # random
    # >>> type(vp.random.random_integers(5))
    # <class 'nlcpy.core.core.ndarray'>
    # >>> vp.random.random_integers(5, size=(3,2))
    # array([[5, 4], # random
    #        [3, 3],
    #        [4, 5]])
    # # Choose five random numbers from the set of five evenly-spaced
    # # numbers between 0 and 2.5, inclusive (*i.e.*, from the set
    # # {0, 5/8, 10/8, 15/8, 20/8}):
    #
    # >>> 2.5 * (vp.random.random_integers(5, size=(5,)) - 1) / 4.
    # array([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random
    #
    # # Roll two six sided dice 1000 times and sum the results:
    #
    # >>> d1 = vp.random.random_integers(1, 6, 1000)
    # >>> d2 = vp.random.random_integers(1, 6, 1000)
    # >>> dsums = d1 + d2
    # @endcode
    # @endpydoc
    # @endif
    def random_integers(self, low, high=None, size=None):
        if high is None:
            """
            warnings.warn(("This function is deprecated. Please call "
                          "randint(1, {low} + 1) instead".format(low=low)).
                          DeprecationWarning)
            """
            high = low
            low = 1
        else:
            """
            warnings.warn(("This function is deprecated. Please call "
                           "randint({low}, {high} + 1) "
                           "instead".format(low=low, high=high)).
                          DeprecationWarning)
            """

        return self.randint(low, int(high) + 1, size=size, dtype='l')

    ## @fn random_sample(self, size=None)
    # @rename generator.RandomState.random_sample random_sample nlcpy.random.RandomState.random_sample
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns random floats in the half-open interval <span class="pre">[0.0, 1.0)</span>.
    # @details Results are from the "continuous uniform" distribution over the
    # stated interval. To sample @f$ Unif[a, b), b > a @f$ multiply
    # the output of random_sample by <em>(b-a)</em> and add <em>a</em>:@n
    # @n
    #  <span class="pre">(b - a) * %random_sample() + a</span>
    # @param  size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.  Default is None, in which case a
    # single value is returned.
    # @retval out : <em>@ref n-dimensional_array "ndarray" of floats</em> @n
    # Array of random floats of shape <em>size</em>.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.random_sample()
    # array([0.80430306]) # random
    # >>> type(vp.random.random_sample())
    # <class 'nlcpy.core.core.ndarray'>
    # >>> vp.random.random_sample((5,))
    # array([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428])
    #
    # # Three-by-two array of random numbers from [-5, 0):
    #
    # >>> 5 * vp.random.random_sample((3, 2)) - 5
    # array([[-3.99149989, -0.52338984], # random
    #        [-2.99091858, -0.79479508],
    #        [-1.23204345, -1.75224494]])
    # @endcode
    # @endpydoc
    # @endif
    def random_sample(self, size=None):
        return self._generate_random_uniform(size=size, dtype=float)

    ## @fn bytes(self, length)
    # @rename generator.RandomState.bytes bytes nlcpy.random.RandomState.bytes
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Returns random bytes.
    # @param length : <em>int</em> @n
    # Number of random bytes.
    # @retval out : <em>str</em> @n
    # String of length <em>length</em>.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.bytes(10)
    # b'\x9fW\xc5\x12\x95\xfd\xba\x0fd\xff' # random
    # @endcode
    # @endpydoc
    # @endif
    def bytes(self, length):
        n_uint32 = ((length - 1) // 4 + 1)
        # '<' is little endian, 'u4' is unsigned 4byte = u32
        return self.randint(0, 424967296, size=n_uint32,
                            dtype='uint32').astype('<u4').tobytes()[:length]

    ## @}
    #
    ## @if(lang_ja)
    # @else
    # @name Permutations
    # @endif
    # @{
    ## @fn shuffle(self, x)
    # @rename generator.RandomState.shuffle shuffle nlcpy.random.RandomState.shuffle
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Modifies a sequence in-place by shuffling its contents.
    # @details This function only shuffles the array along the first axis of a
    # multi-dimensional array. The order of sub-arrays is changed but
    # their contents remains the same.
    # @param x : <em>array_like</em> @n
    # The array or list to be shuffled.
    # @retval None
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> arr = vp.arange(10)
    # >>> vp.random.shuffle(arr)
    # >>> arr
    # array([7, 1, 5, 6, 0, 8, 4, 2, 9, 3]) # random
    #
    # # Multi-dimensional arrays are only shuffled along the first axis:
    #
    # >>> arr = vp.arange(9).reshape((3, 3))
    # >>> vp.random.shuffle(arr)
    # >>> arr
    # array([[3, 4, 5], # random
    #        [6, 7, 8],
    #        [0, 1, 2]])
    # @endcode
    # @endpydoc
    # @endif
    def shuffle(self, x):
        n = len(x)
        if isinstance(x, nlcpy.ndarray):
            self._generate_random_shuffle(x)
        else:
            # Untyped path.
            random_interval = self.randint(0, high=n, size=n)
            for i in reversed(range(0, n)):
                j = random_interval.get().flat[i]
                x[i], x[j] = x[j], x[i]
        return

    ## @fn permutation(self, x)
    # @rename generator.RandomState.permutation permutation nlcpy.random.RandomState.permutation
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Randomly permutes a sequence, or returns a permuted range.
    # @details If <em>x</em> is a multi-dimensional array, it is only shuffled along it
    # first index.
    # @param x : <em>int or array_like</em> @n
    # If <em>x</em> is an integer, randomly permute <span class="pre">vp.arange(x)</span>.
    # If <em>x</em> is an array, make a copy and shuffle the elements
    # randomly.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Permuted sequence or array range.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.permutation(10)
    # array([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random
    #
    # >>> vp.random.permutation([1, 4, 9, 12, 15])
    # array([15,  1,  9,  4, 12]) # random
    #
    # >>> arr = vp.arange(9).reshape((3, 3))
    # >>> vp.random.permutation(arr)
    # array([[6, 7, 8], # random
    #        [0, 1, 2],
    #        [3, 4, 5]])
    # @endcode
    # @endpydoc
    # @endif
    def permutation(self, x):
        if isinstance(x, (int, nlcpy.integer)):
            arr = nlcpy.arange(x)
            self.shuffle(arr)
            return arr

        arr = nlcpy.asarray(x)
        if arr.ndim < 1:
            raise IndexError("x must be an integer or at least 1-dimensional")

        if nlcpy.may_share_memory(arr, x):
            arr = nlcpy.array(arr)
        self.shuffle(arr)
        return arr

    ## @}
    #
    ## @if(lang_ja)
    # @else
    # @name Distributions
    # @endif
    # @{
    ## @fn binomial(self, n, p, size=None)
    # @rename generator.RandomState.binomial binomial nlcpy.random.RandomState.binomial
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a binomial distribution.
    # @details Samples are drawn from a binomial distribution with specified
    # parameters, n trials and p probability of success where
    # n an integer >= 0 and p is in the interval <span class="pre">[0,1]</span>. (n may be
    # input as a float, but it is truncated to an integer in use)
    # @param n : <em>int</em> @n
    # Parameter of the distribution, >= 0. Floats are also accepted,
    # but they will be truncated to integers.
    # @param p : <em>float</em> @n
    # Parameter of the distribution, >= 0 and <=1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized binomial distribution, where
    # each sample is equal to the number of successes over the n trials.
    # @attention
    # @raise @em n is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em p is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the binomial distribution is@n
    # @n
    #  @f$ P(N) = {n \choose N}p^N(1-p)^{n-N}, @f$ @n
    # @n
    # where @f$n@f$ is the number of trials, @f$p@f$ is the probability
    # of success, and @f$N@f$ is the number of successes.@n
    # @n
    # When estimating the standard error of a proportion in a population by
    # using a random sample, the normal distribution works well unless the
    # product p*n <=5, where p = population proportion estimate, and n =
    # number of samples, in which case the binomial distribution is used
    # instead.@n
    # For example, a sample of 15 people shows 4 who are left
    # handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,
    # so the binomial distribution should be used in this case.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> n, p = 10, .5  # number of trials, probability of each trial
    # >>> s = vp.random.binomial(n, p, 1000)
    # # result of flipping a coin 10 times, tested 1000 times.
    #
    # # A real world example. A company drills 9 wild-cat oil exploration
    # # wells, each with an estimated probability of success of 0.1. All nine
    # # wells fail. What is the probability of that happening?
    #
    # # Let's do 20,000 trials of the model, and count the number that
    # # generate zero positive results.
    #
    # >>> sum(vp.random.binomial(9, 0.1, 20000) == 0)/20000.
    # # array(0.38625), or 38%.
    # @endcode
    # @endpydoc
    # @endif
    def binomial(self, n, p, size=None):
        self._is_number(n, p)
        if p < 0 or p > 1 or p is nan:
            raise ValueError('p < 0, p > 1 or p is NaN')
        _size = size if size is not None else broadcast(
            asarray(n), asarray(p)).shape
        return self._generate_random_binomial(n, p, size=_size, dtype=int)

    ## @fn exponential(self, scale=1.0, size=None)
    # @rename generator.RandomState.exponential exponential nlcpy.random.RandomState.exponential
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from an exponential distribution.
    # @details Its probability density function is@n
    # @n
    #  @f$ f(x; \frac{1}{\beta}) = \frac{1}{\beta} \exp(-\frac{x}{\beta}), @f$ @n
    # @n
    # for <span class="pre">x > 0</span> and 0 elsewhere. @f$\beta@f$ is the scale parameter,
    # which is the inverse of the rate parameter @f$ \lambda = 1/\beta @f$.
    # @param scale : <em>float</em> @n
    # The scale parameter, @f$ \beta = 1/\lambda @f$. Must be
    # non-negative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized exponential distribution.
    # @attention
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @endpydoc
    # @endif
    def exponential(self, scale=1.0, size=None):
        self._is_number(scale)
        if scale < 0:
            raise ValueError('scale < 0')

        _size = size if size is not None else asarray(scale).shape
        return self._generate_random_exponential(
            scale, size=_size, dtype=float)

    ## @fn gamma(self, shape, scale=1.0, size=None)
    # @rename generator.RandomState.gamma gamma nlcpy.random.RandomState.gamma
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Gamma distribution.
    # @details Samples are drawn from a Gamma distribution with specified parameters,
    # <em>shape</em> (sometimes designated "k") and <em>scale</em> (sometimes designated
    # "theta"), where both parameters are > 0.
    # @param shape : <em>float</em> @n
    # The shape of the gamma distribution. Must be non-negative.
    # @param scale : <em>float, @b optional</em> @n
    # The scale of the gamma distribution. Must be non-negative.
    # Default is equal to 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized gamma distribution.
    # @attention
    # @raise @em shape is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Gamma distribution is@n
    # @n
    #  @f$ p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)}, @f$ @n
    # @n
    # where @f$k@f$ is the shape and @f$\theta@f$ the scale,
    # and @f$\Gamma@f$ is the Gamma function.@n
    # @n
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)
    # >>> s = vp.random.gamma(shape, scale, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def gamma(self, shape, scale=1.0, size=None):
        self._is_number(shape, scale)
        if shape < 0:
            raise ValueError('shape < 0')
        if scale < 0:
            raise ValueError('scale < 0')
        _size = size if size is not None else broadcast(
            asarray(shape), asarray(scale)).shape
        return self._generate_random_gamma(
            shape, scale, size=_size, dtype=float)

    ## @fn geometric(self, p, size=None)
    # @rename generator.RandomState.geometric geometric nlcpy.random.RandomState.geometric
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a geometric distribution.
    # @details Bernoulli trials are experiments with one of two outcomes:
    # success or failure (an example of such an experiment is flipping
    # a coin).  The geometric distribution models the number of trials
    # that must be run in order to achieve success.@n 
    # It is therefore supported on the positive integers, <span class="pre">k = 1, 2, ...</span>.@n
    # @n
    # The probability mass function of the geometric distribution is@n
    # @n
    #  @f$ f(k) = (1 - p)^{k - 1} p @f$ @n
    # @n
    # where <em>p</em> is the probability of success of an individual trial.
    # @param p : <em>float</em> @n
    # The probability of success of an individual trial.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized geometric distribution.
    # @attention
    # @raise @em p is neither a scalar nor None : @em NotImplementedError occurs.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw ten thousand values from the geometric distribution,
    # # with the probability of an individual success equal to 0.35:
    #
    # >>> z = vp.random.geometric(p=0.35, size=10000)
    #
    # # How many trials succeeded after a single run?
    #
    # >>> (z.get() == 1).sum() / 10000.
    # 0.2235  # random
    # @endcode
    # @endpydoc
    # @endif
    def geometric(self, p, size=None):
        self._is_number(p)
        if p <= 0 or p > 1:
            raise ValueError('p <= 0, p > 1 or p contains NaNs')
        _size = size if size is not None else asarray(p).shape
        return self._generate_random_geometric(p, size=size, dtype=int)

    ## @fn gumbel(self, loc=0.0, scale=1.0, size=None)
    # @rename generator.RandomState.gumbel gumbel nlcpy.random.RandomState.gumbel
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Gumbel distribution.
    # @details Draws samples from a Gumbel distribution with specified location and
    # scale.  For more information on the Gumbel distribution, see
    # Notes and References below.
    # @param loc : <em>float, @b optional</em> @n
    # The location of the mode of the distribution. Default is 0.
    # @param scale : <em>float, @b optional</em> @n
    # The scale parameter of the distribution. Default is 1. Must be non-negative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized Gumbel distribution.
    # @sa @li @ref weibull "weibull" : Draws samples from a Weibull distribution.
    # @attention
    # @raise @em loc is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Gumbel distribution is@n
    # @n
    #  @f$ p(x) = \frac{e^{-(x - \mu)/ \beta}}{\beta} e^{ -e^{-(x - \mu)/ \beta}}, @f$ @n
    # @n
    # where @f$\mu@f$ is the mode, a location parameter, and
    #  @f$\beta@f$ is the scale parameter.@n
    # @n
    # The function has a mean of @f$ \mu + 0.57721\beta @f$ and a variance
    # of @f$ \frac{\pi^2}{6}\beta^2 @f$.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> mu, beta = 0, 0.1 # location and scale
    # >>> s = vp.random.gumbel(mu, beta, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def gumbel(self, loc=0.0, scale=1.0, size=None):
        self._is_number(loc, scale)
        if scale < 0:
            raise ValueError('scale < 0')

        # ASL Lib is different numpy : add [Result * -1]
        ret = self._generate_random_gumbel(loc, scale, size=size, dtype=float)
        return (ret * -1 if ret.size > 1 or ret != 0 else ret)

    ## @fn logistic(self, loc=0.0, scale=1.0, size=None)
    # @rename generator.RandomState.logistic logistic nlcpy.random.RandomState.logistic
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a logistic distribution.
    # @details Samples are drawn from a logistic distribution with specified
    # parameters, <em>loc</em> (location or mean, also median), and <em>scale</em> (>0).
    # @param loc : <em>float, @b optional</em> @n
    # Parameter of the distribution. Default is 0.
    # @param scale : <em>float, @b optional</em> @n
    # Parameter of the distribution. Must be non-negative.
    # Default is 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized logistic distribution.
    # @attention
    # @raise @em loc is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Logistic distribution is@n
    # @n
    #  @f$ P(x) = \frac{e^{-(x-\mu)/s}}{s(1+e^{-(x-\mu)/s})^2}, @f$ @n
    # @n
    # where @f$\mu@f$ = location and @f$s@f$ = scale.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> loc, scale = 10, 1
    # >>> s = vp.random.logistic(loc, scale, 10000)
    # @endcode
    # @endpydoc
    # @endif
    def logistic(self, loc=0.0, scale=1.0, size=None):
        self._is_number(loc, scale)
        _size = size if size is not None else broadcast(
            asarray(loc), asarray(scale)).shape
        return self._generate_random_logistic(
            loc, scale, size=_size, dtype=float)

    ## @fn lognormal(self, mean=0.0, sigma=1.0, size=None)
    # @rename generator.RandomState.lognormal lognormal nlcpy.random.RandomState.lognormal
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a log-normal distribution.
    # @details Draws samples from a log-normal distribution with specified mean,
    # standard deviation, and array shape.  Note that the mean and standard
    # deviation are not the values for the distribution itself, but of the
    # underlying normal distribution it is derived from.
    # @param mean : <em>float, @b optional</em> @n
    # Mean value of the underlying normal distribution. Default is 0.
    # @param sigma : <em>float, @b optional</em> @n
    # Standard deviation of the underlying normal distribution. Must be
    # non-negative. Default is 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized log-normal distribution.
    # @attention
    # @raise @em mean is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em sigma is neither a scalar nor None : @em NotImplementedError occurs.
    # @note A variable <em>x</em> has a log-normal distribution if <em>log(x)</em> is normally
    # distributed.  The probability density function for the log-normal
    # distribution is:@n
    # @n
    #  @f$ p(x) = \frac{1}{\sigma x \sqrt{2\pi}}e^{(-\frac{(ln(x)-\mu)^2}{2\sigma^2})} @f$ @n
    # @n
    # where @f$\mu@f$ is the mean and @f$\sigma@f$ is the standard
    # deviation of the normally distributed logarithm of the variable.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> mu, sigma = 3., 1. # mean and standard deviation
    # >>> s = vp.random.lognormal(mu, sigma, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def lognormal(self, mean=0.0, sigma=1.0, size=None):
        self._is_number(mean, sigma)
        if sigma < 0:
            raise ValueError('sigma < 0')
        return self._generate_random_lognormal(
            mean, sigma, size=size, dtype=float)

    ## @fn normal(self, loc=0.0, scale=1.0, size=None)
    # @rename generator.RandomState.normal normal nlcpy.random.RandomState.normal
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws random samples from a normal (Gaussian) distribution.
    # @details The probability density function of the normal distribution, first
    # derived by De Moivre and 200 years later by both Gauss and Laplace
    # independently, is often called the bell curve because of
    # its characteristic shape (see the example below).@n
    # @n
    # The normal distributions occurs often in nature.  For example, it
    # describes the commonly occurring distribution of samples influenced
    # by a large number of tiny, random disturbances, each with its own
    # unique distribution.
    # @param loc : <em>float</em> @n
    # Mean ("centre") of the distribution.
    # @param scale : <em>float</em> @n
    # Standard deviation (spread or "width") of the distribution. Must be
    # non-negative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized normal distribution.
    # @attention
    # @raise @em loc is neither a scalar nor None : @em NotImplementedError occurs. 
    # @raise @em scale is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Gaussian distribution is@n
    # @n
    #  @f$ p(x) = \frac{1}{\sqrt{ 2 \pi \sigma^2 }}e^{ - \frac{ (x - \mu)^2 } {2 \sigma^2} }, @f$ @n
    # @n
    # where @f$\mu@f$ is the mean and @f$\sigma@f$ the standard@n
    # deviation. The square of the standard deviation, @f$\sigma^2@f$,
    # is called the variance.@n
    # @n
    # The function has its peak at the mean, and its "spread" increases with
    # the standard deviation (the function reaches 0.607 times its maximum at
    # @f$x + \sigma@f$ and @f$x - \sigma@f$).  This implies that
    # <em>numpy.random.normal</em> is more likely to return samples lying close to
    # the mean, rather than those far away.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> mu, sigma = 0, 0.1 # mean and standard deviation
    # >>> s = vp.random.normal(mu, sigma, 1000)
    #
    # # Verify the mean and the variance:
    #
    # >>> abs(mu - vp.mean(s))
    # array(0.00206415)  # may vary
    #
    # >>> abs(sigma - vp.std(s, ddof=1))
    # array(0.00133596)  # may vary
    #
    # # Two-by-four array of samples from N(3, 6.25):
    #
    # >>> vp.random.normal(3, 2.5, size=(2, 4))
    # array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
    #        [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
    # @endcode
    # @endpydoc
    # @endif
    def normal(self, loc=0.0, scale=1.0, size=None):
        self._is_number(loc, scale)
        if scale < 0:
            raise ValueError('scale < 0')
        return self._generate_random_normal(loc, scale, size=size, dtype=float)

    ## @fn poisson(self, lam=1.0, size=None)
    # @rename generator.RandomState.poisson poisson nlcpy.random.RandomState.poisson
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Poisson distribution.
    # @details The Poisson distribution is the limit of the binomial distribution
    # for large N.
    # @param lam : <em>float</em> @n
    # Expectation of interval, must be >= 0. A sequence of expectation
    # intervals must be broadcastable over the requested size.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized Poisson distribution.
    # @attention
    # @raise @em lam is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The Poisson distribution@n
    # @n
    #  @f$ f(k; \lambda)=\frac{\lambda^k e^{-\lambda}}{k!} @f$ @n
    # @n
    # For events with an expected separation @f$\lambda@f$ the Poisson
    # distribution @f$f(k; \lambda)@f$ describes the probability of
    #  @f$k@f$ events occurring within the observed
    # interval @f$\lambda@f$.@n
    # @n
    # Because the output is limited to the range of the C int64 type, a
    # ValueError is raised when <em>lam</em> is within 10 sigma of the maximum
    # representable value.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> s = vp.random.poisson(5, 10000)
    # @endcode
    # @endpydoc
    # @endif
    def poisson(self, lam=1.0, size=None):
        self._is_number(lam)
        if lam < 0 or lam is nan:
            raise ValueError('lam < 0 or lam is NaN')
        if lam > numpy.iinfo('l').max - numpy.sqrt(numpy.iinfo('l').max) * 10:
            raise ValueError('lam value too large')
        _size = size if size is not None else asarray(lam).shape
        return self._generate_random_poisson(lam, size=_size, dtype=int)

    ## @fn standard_cauchy(self, size=None)
    # @rename generator.RandomState.standard_cauchy standard_cauchy nlcpy.random.RandomState.standard_cauchy
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard Cauchy distribution with mode = 0.
    # @details Also known as the Lorentz distribution.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval samples : <em>@ref n-dimensional_array "ndarray"</em> @n
    # The drawn samples.
    # @note The probability density function for the full Cauchy distribution is@n
    # @n
    #  @f$ P(x; x_0, \gamma) = \frac{1}{\pi \gamma \bigl[ 1+(\frac{x-x_0}{\gamma})^2 \bigr] } @f$ @n
    # @n
    # and the Standard Cauchy distribution just sets @f$ x_0=0 @f$ and
    # @f$ \gamma=1 @f$
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples and plot the distribution:
    #
    # >>> s = vp.random.standard_cauchy(1000000)
    # @endcode
    # @endpydoc
    # @endif
    def standard_cauchy(self, size=None):
        return self._generate_random_cauchy(
            a=0.0, b=1.0, size=size, dtype=float)

    ## @fn standard_exponential(self, size=None)
    # @rename generator.RandomState.standard_exponential standard_exponential nlcpy.random.RandomState.standard_exponential
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard exponential distribution.
    # @details standard_exponential is identical to the exponential distribution
    # with a scale parameter of 1.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples.
    # @sa @li @ref exponential "exponential" : Draws samples from an %exponential distribution.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Output a 3x8000 array:
    #
    # >>> n = vp.random.standard_exponential((3, 8000))
    # @endcode
    # @endpydoc
    # @endif
    def standard_exponential(self, size=None):
        return self.exponential(scale=1.0, size=size)

    ## @fn standard_gamma(self, shape, size=None)
    # @rename generator.RandomState.standard_gamma standard_gamma nlcpy.random.RandomState.standard_gamma
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard Gamma distribution.
    # @details Samples are drawn from a Gamma distribution with specified parameters,
    # shape (sometimes designated "k") and scale=1.
    # @param shape : <em>float</em> @n
    # Parameter, must be non-negative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized standard gamma distribution.
    # @attention
    # @raise @em shape is neither a scalar nor None : @em NotImplementedError occurs
    # @note The probability density for the Gamma distribution is@n
    # @n
    #  @f$ p(x) = x^{k-1}\frac{e^{-x/\theta}}{\theta^k\Gamma(k)}, @f$ @n
    # @n
    # where @f$k@f$ is the shape and @f$\theta@f$ the scale,
    # and @f$\Gamma@f$ is the Gamma function.@n
    # @n
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> shape, scale = 2., 1. # mean and width
    # >>> s = vp.random.standard_gamma(shape, 1000000)
    # @endcode
    # @endpydoc
    # @endif
    def standard_gamma(self, shape, size=None):
        return self.gamma(shape, scale=1.0, size=size)

    ## @fn standard_normal(self, size=None)
    # @rename generator.RandomState.standard_normal standard_normal nlcpy.random.RandomState.standard_normal
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a standard Normal distribution (mean=0, stdev=1).
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # A floating-point array of shape <span class="pre">size</span> of drawn samples, or a
    # single sample if <span class="pre">size</span> was not specified.
    # @sa @li normal : Draws %random samples from a %normal (Gaussian) distribution. "normal"
    # @note For random samples from @f$N(\mu, \sigma^2) @f$, use one of: @code 
    # import nlcpy as vp
    # mu + sigma * vp.random.standard_normal(size=...)
    # vp.random.normal(mu, sigma, size=...) @endcode 
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # >>> vp.random.standard_normal()
    # 2.1923875335537315 # random
    #
    # >>> s = vp.random.standard_normal(8000)
    # >>> s
    # array([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random
    #        -0.38672696, -0.4685006 ])                                # random
    # >>> s.shape
    # (8000,)
    # >>> s = vp.random.standard_normal(size=(3, 4, 2))
    # >>> s.shape
    # (3, 4, 2)
    #
    # # Two-by-four array of samples from N(3, 6.25):
    #
    # >>> 3 + 2.5 * vp.random.standard_normal(size=(2, 4))
    # array([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random
    #        [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random
    # @endcode
    # @endpydoc
    # @endif
    def standard_normal(self, size=None):
        return self.normal(loc=0.0, scale=1.0, size=size)

    ## @fn uniform(self, low=0.0, high=1.0, size=None)
    # @rename generator.RandomState.uniform uniform nlcpy.random.RandomState.uniform
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a uniform distribution.
    # @details Samples are uniformly distributed over the half-open interval
    # <span class="pre">[low, high)</span> (includes low, but excludes high).  In other words,@n
    # any value within the given interval is equally likely to be drawn
    # by uniform.
    # @param low : <em>float, @b optional</em> @n
    # Lower boundary of the output interval.  All values generated will be
    # greater than or equal to low.  The default value is 0.
    # @param high : <em>float</em> @n
    # Upper boundary of the output interval.  All values generated will be
    # less than high.  The default value is 1.0.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized uniform distribution.
    # @sa @li @ref randint "randint" : Returns %random integers from low (inclusive) to high (exclusive).
    # @sa @li @ref random_integers "random_integers" : Random integers of type np.int between low and high, inclusive.
    # @sa @li @ref random_sample "random_sample" : Returns %random floats in the half-open interval <span class="pre">[0.0, 1.0)</span>.
    # @sa @li @ref random "random" : Returns %random floats in the half-open interval <span class="pre">[0.0, 1.0)</span>.
    # @sa @li @ref rand "rand" : Random values in a given %shape.
    # @attention
    # @raise @em low is neither a scalar nor None : @em NotImplementedError occurs.
    # @raise @em high is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density function of the uniform distribution is@n
    # @n
    #  @f$ p(x) = \frac{1}{b - a} @f$ @n
    # @n
    # anywhere within the interval <span class="pre">[a, b)</span>, and zero elsewhere.@n
    # @n
    # When <span class="pre">high</span> == <span class="pre">low</span>, values of <span class="pre">low</span> will be returned.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> s = vp.random.uniform(-1,0,1000)
    #
    # # All values are within the given interval:
    #
    # >>> vp.all(s >= -1)
    # array(True)
    # >>> vp.all(s < 0)
    # array(True)
    # @endcode
    # @endpydoc
    # @endif
    def uniform(self, low=0.0, high=1.0, size=None):
        rand = self._generate_random_uniform(size=size, dtype=float)

        # isscalar is not nlcpy. use numpy.
        if not numpy.isscalar(low):
            low = ndarray(low, float)
        if not numpy.isscalar(high):
            high = ndarray(high, float)
        rand = (high - low) * rand + low
        return rand

    ## @fn weibull(self, a, size=None)
    # @rename generator.RandomState.weibull weibull nlcpy.random.RandomState.weibull
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Draws samples from a Weibull distribution.
    # @details Draws samples from a 1-parameter Weibull distribution with the given
    # shape parameter <em>a</em>.@n
    # @n
    #  @f$ X = (-ln(U))^{1/a} @f$ @n
    # @n
    # Here, U is drawn from the uniform distribution over <span class="pre">(0,1]</span>.@n
    # @n
    # The more common 2-parameter Weibull, including a scale parameter
    # @f$\lambda@f$ is just @f$ X = \lambda(-ln(U))^{1/a} @f$.
    # @param a : <em>float</em> @n
    # Shape parameter of the distribution.  Must be nonnegative.
    # @param size : <em>int or tuple of ints, @b optional</em> @n
    # Output shape.  If the given shape is, e.g., <span class="pre">(m, n, k)</span>, then
    # <span class="pre">m * n * k</span> samples are drawn.
    # @retval out : <em>@ref n-dimensional_array "ndarray"</em> @n
    # Drawn samples from the parameterized Weibull distribution.
    # @sa @li @ref gumbel "gumbel" : Draws samples from a Gumbel distribution.
    # @attention
    # @raise @em a is neither a scalar nor None : @em NotImplementedError occurs.
    # @note The probability density for the Weibull distribution is@n
    # @n
    #  @f$ p(x) = \frac{a}{\lambda}(\frac{x}{\lambda})^{a-1}e^{-(x/\lambda)^a}, @f$ @n
    # @n
    # where @f$a@f$ is the shape and @f$\lambda@f$ the scale.@n
    # @n
    # The function has its peak (the mode) at@n
    #  @f$ \lambda(\frac{a-1}{a})^{1/a}. @f$ @n
    # @n
    # When <span class="pre">a = 1</span>, the Weibull distribution reduces to the exponential
    # distribution.
    # @par Example
    # @code
    # >>> import nlcpy as vp
    # # Draw samples from the distribution:
    #
    # >>> a = 5. # shape
    # >>> s = vp.random.weibull(a, 1000)
    # @endcode
    # @endpydoc
    # @endif
    def weibull(self, a, size=None):
        self._is_number(a)
        if a < 0:
            raise ValueError('a < 0')

        _size = size if size is not None else asarray(a).shape
        return self._generate_random_weibull(a, b=1.0, size=size, dtype=float)

    ## @}
    #
    ## @if(lang_ja)
    # @else
    # @name Seeding and State
    # @endif
    # @{
    ## @fn seed(self, seed=None)
    # @rename generator.RandomState.seed seed nlcpy.random.RandomState.seed
    # @ingroup ClassRandomState
    # @if(lang_ja)
    # @else
    # @pydoc
    # @brief Reseeds a default bit generator(MT19937), which provide a stream of random bits.
    # @note This is a convenience, legacy function.
    # The best practice is to **not** reseed a BitGenerator, rather to
    # recreate a new one. This method is here for legacy reasons.
    # This example demonstrates best practice.
    # @par Example
    # @code
    # >>> from nlcpy as vp
    # >>> rs = vp.random.RandomState(123456789)
    # # Later, you want to restart the stream
    # >>> rs.seed(987654321)
    # @endcode
    # @endpydoc
    # @endif
    def seed(self, seed=None):
        if seed is None:
            import random
            r = random.randint(0, self._asl_seed_max)
            self._ve_seed = nlcpy.array(r, dtype='u4')
        else:
            self._ve_seed = nlcpy.asarray(seed)
            if self._ve_seed.size == 0:
                raise ValueError("Seed must be non-empty")
            if self._ve_seed.ndim > 1:
                raise ValueError("Seed array must be 1-d")
            if nlcpy.any(self._ve_seed < 0) or nlcpy.any(
                    self._ve_seed > self._asl_seed_max):
                raise ValueError('Seed must be between 0 and 2**32 - 1')
            self._ve_seed = self._ve_seed.astype(dtype='u4', copy=False)
            request.flush()

        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()
        args = (self._ve_seed._ve_array,
                veo.OnStack(fpe_flags, inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_set_seed"](v.ctx, *args)
        ret = req.wait_result()
        self._vh_seed = self._ve_seed.get()

    ## @}
    #
    def _update_vh_seed(self, size):
        self._vh_seed = self._vh_seed + size
        self._vh_seed %= self._asl_seed_max

    def _is_number(self, *param):
        for p in param:
            if not isinstance(p, numbers.Number):
                raise NotImplementedError('Array is not supported')

    def _asl_error_check(self, ret):
        if ret != ASL_ERROR_OK:
            if ret == ASL_ERROR_ARGUMENT:
                raise RuntimeError('[ASL_ERR] incorrect argument')
            elif ret == ASL_ERROR_LIBRARY_UNINITIALIZED:
                raise RuntimeError('[ASL_ERR] library not initialized')
            elif ret == ASL_ERROR_RANDOM_INVALID:
                raise RuntimeError(
                    '[ASL_ERR] invalid random number generator handle')
            elif ret == ASL_ERROR_MEMORY:
                raise RuntimeError('[ASL_ERR] out of memory')
            elif ret == ASL_ERROR_MPI:
                raise RuntimeError(
                    '[ASL_ERR] MPI error (only when parallelly excuted)')
            elif ret == ASL_ERROR_RANDOM_INCOMPATIBLE_CALL:
                raise RuntimeError(
                    '[ASL_ERR] not in a continuous distribution')
            else:
                raise RuntimeError(
                    '[ASL_ERR] unexpected err code=%s' %
                    str(ret))

    def _asl_get_state(self):
        v = veo.VeoAlloc()

        req = v.lib.func[b"nlcpy_random_get_state_size"](v.ctx, None)
        shape = req.wait_result()

        state = ndarray(shape, dtype=nlcpy.uint32)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        args = (state._ve_array, veo.OnStack(fpe_flags, inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_save_state"](v.ctx, *args)

        ret = req.wait_result()
        self._asl_error_check(ret)

        return state

    def _asl_set_state(self, state):
        v = veo.VeoAlloc()

        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        args = (state._ve_array, veo.OnStack(fpe_flags, inout=veo.INTENT_OUT))

        req = v.lib.func[b"nlcpy_random_restore_state"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)
        return

    def _generate_random_uniform(self, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (out._ve_array, veo.OnStack(fpe_flags, inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_uniform_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_integers(self, low, high, size=None, dtype=int):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        out = ndarray(shape=size, dtype=dtype)
        work = ndarray(shape=size, dtype=nlcpy.uint64)

        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            work._ve_array,
            low,
            high - low,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_integers"](v.ctx, *args) \
            if numpy.dtype(dtype).name not in _unsigned_integers_types \
            else v.lib.func[b"nlcpy_random_generate_unsigned_integers"](v.ctx, *args)
        ret = req.wait_result()

        self._asl_error_check(ret)

        return out

    def _generate_random_normal(self, loc, scale, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if scale == 0.:
            return nlcpy.zeros(size, dtype=int)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            loc,
            scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_normal_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_gamma(self, shape, scale, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if shape == 0. or scale == 0.:
            return nlcpy.zeros(size, dtype=int)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            shape,
            1 / scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_gamma_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_poisson(self, lam, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if lam == 0:
            return nlcpy.zeros(size, int)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            lam,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_poisson_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_logistic(self, loc, scale, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            loc,
            scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_logistic_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_weibull(self, a, b, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if a == 0.:
            return nlcpy.zeros(size, dtype=int)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            a,
            b,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_weibull_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_exponential(self, scale=1.0, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if scale == 0.:
            return nlcpy.zeros(size, dtype=int)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_exponential_f64"](
            v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_cauchy(self, a=0.0, b=1.0, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            a,
            b,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_cauchy_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_lognormal(
            self, mean=0.0, sigma=1.0, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if sigma == 0.:
            return nlcpy.ones(size, dtype)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            mean,
            sigma,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_lognormal_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_gumbel(
            self, loc=0.0, scale=1.0, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if scale == 0.:
            return nlcpy.zeros(size, dtype=int)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            loc,
            scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_gumbel_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_geometric(self, p, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (out._ve_array, p, veo.OnStack(fpe_flags, inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_geometric_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_binomial(self, n, p, size=None, dtype=float):
        if size is None:
            size = ()
        if not numpy.isscalar(size) and len(size) == 0:
            size = ()

        if n == 0 or p == 0 or p == 1:
            return nlcpy.zeros(size, int)

        out = ndarray(shape=size, dtype=dtype)
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            n,
            p,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_binomial_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return out

    def _generate_random_uniform_for_generator(self, size=None, out=None):
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (out._ve_array, veo.OnStack(fpe_flags, inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_uniform_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return

    def _generate_random_exponential_for_generator(
            self, scale=1.0, size=None, out=None):
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_exponential_f64"](
            v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return

    def _generate_random_normal_for_generator(
            self, loc=0.0, scale=1.0, size=None, out=None):
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            loc,
            scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_normal_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return

    def _generate_random_gamma_for_generator(
            self, shape, scale=1.0, size=None, out=None):
        fpe_flags = numpy.empty(1, dtype=numpy.int32)
        v = veo.VeoAlloc()

        args = (
            out._ve_array,
            shape,
            1 / scale,
            veo.OnStack(
                fpe_flags,
                inout=veo.INTENT_OUT))
        req = v.lib.func[b"nlcpy_random_generate_gamma_f64"](v.ctx, *args)
        ret = req.wait_result()
        self._asl_error_check(ret)

        return

    def _generate_random_shuffle(self, x):
        if x.ndim == 0 or x.size == 1:
            return
        for i in range(x.ndim):
            if x._shape[i] == 0:
                return
        fpe_flags = numpy.empty(1, dtype=numpy.int32)

        np_state = numpy.random.get_state()
        numpy.random.seed(self._vh_seed)
        self._update_vh_seed(x.size)

        shuffle_idx = numpy.arange(x.shape[0], dtype='i8')
        numpy.random.shuffle(shuffle_idx)
        shuffle_idx = nlcpy.array(shuffle_idx, dtype='i8')
        shuffle_work = x.copy()

        numpy.random.set_state(np_state)

        request._push_request(
            "nlcpy_random_shuffle",
            "random_op",
            (x, shuffle_idx, shuffle_work),
        )
        return


_rand = RandomState()
