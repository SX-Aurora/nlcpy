# distutils: language = c++
#
# * The source code in this file is based on the soure code of NumPy.
#
# # NLCPy License #
#
#     Copyright (c) 2020 NEC Corporation
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither NEC Corporation nor the names of its contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# # NumPy License #
#
#     Copyright (c) 2005-2020, NumPy Developers.
#     All rights reserved.
#
#     Redistribution and use in source and binary forms, with or without
#     modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright notice,
#       this list of conditions and the following disclaimer in the documentation
#       and/or other materials provided with the distribution.
#     * Neither the name of the NumPy Developers nor the names of any contributors may be
#       used to endorse or promote products derived from this software
#       without specific prior written permission.
#
#     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
#     FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#     ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
import nlcpy
import warnings
import numpy
from nlcpy.wrapper.numpy_wrap import numpy_wrap
cimport cython
cimport cpython


##
# @name Order statistics
# @{
#
## @fn amax(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)
# @rename order.amax amax nlcpy.amax
# @ingroup Order_statistics
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns the maximum of an array or maximum along an axis.
# @details
# @param a : <em>array_like</em> @n
#   Array containing numbers whose maximum is desired. If @em a is not an array, a conversion is attempted.
# @param axis : <em>None or int or tuple of ints, @b optional</em> @n
#   Axis or axes along which to operate. By default, flattened input is used. @n
#   If this is a tuple of ints, the maximum is selected over multiple axes.
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   Alternative output array in which to place the result.
#   Must be of the same shape and buffer length as the expected output.
# @param keepdims : <em>bool, @b optional</em> @n
#   If this is set to True, the axes which are reduced are left in the result as dimensions with size one.
#   With this option, the result will broadcast correctly against the input array.
# @param initial : <em>scalar, @b optional</em> @n
#   The maximum value of an output element. Must be present to allow computation on empty slice.
#   See @ref ufunc.reduce "reduce" for details.
# @param where : <em>array_like of bool, @b optional</em> @n
#   Elements to compare for the maximum. See @ref ufunc.reduce "reduce" for details.
# @retval amax : <em>@ref n-dimensional_array "ndarray"</em> @n
#   An array with the same shape as @em a, with the specified axis removed. If @em a is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as @em a is returned.
# @sa
#   @li @ref amin : Returns the minimum of an array or minimum along an axis.
#   @li @ref nanmax : Returns maximum of an array or maximum along an axis, ignoring %any NaNs.
#   @li @ref ufuncs.maximum "maximum" : Element-wise maximum of array elements.
#   @li @ref ufuncs.fmax "fmax" : Element-wise maximum of array elements.
#   @li @ref searching.argmax "argmax" : Returns the indices of the maximum values along an axis.
#   @li @ref nanmin : Returns the minimum of an array or minimum along an axis, ignoring %any NaNs.
#   @li @ref ufuncs.minimum "minimum" : Element-wise minimum of array elements.
#   @li @ref ufuncs.fmin "fmin" : Element-wise minimum of array elements.
# @note
#   NaN values are propagated, that is if at least one item is NaN, the corresponding max value will be NaN as well. To ignore NaN values, please use nanmax. @n
#   Don't use @ref amax for element-wise comparison of 2 arrays; when <span class="pre">a.shape[0]</span> is 2, <span class="pre">maximum(a[0], a[1])</span> is faster than <span class="pre">amax(a, axis=0)</span>.
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.arange(4).reshape((2,2))
# >>> a
# array([[0, 1],
#        [2, 3]])
# >>> vp.amax(a)           # Maximum of the flattened array
# array(3)
# >>> vp.amax(a, axis=0)   # Maxima along the first axis
# array([2, 3])
# >>> vp.amax(a, axis=1)   # Maxima along the second axis
# array([1, 3])
# >>> vp.amax(a, where=[False, True], initial=-1, axis=0)
# array([-1,  3])
# @endcode @n
# @code
# >>> b = vp.arange(5, dtype=float)
# >>> b[2] = vp.NaN
# >>> vp.amax(b)
# array(nan)
# >>> vp.amax(b, where=~vp.isnan(b), initial=-1)
# array(4.0)
# >>> vp.nanmax(b)
# array(4.0)
# @endcode
# @endpydoc
# @endif
def amax(a, axis=None, out=None, keepdims=nlcpy._NoValue,
         initial=nlcpy._NoValue, where=nlcpy._NoValue):
    args = dict()
    if keepdims is not nlcpy._NoValue:
        args["keepdims"] = keepdims
    if initial is not nlcpy._NoValue:
        args["initial"] = initial
    if where is not nlcpy._NoValue:
        args["where"] = where
    return nlcpy.maximum.reduce(a, axis=axis, out=out, **args)


## @fn amin(a, axis=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)
# @rename order.amin amin nlcpy.amin
# @ingroup Order_statistics
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns the minimum of an array or minimum along an axis.
# @details
# @param a : <em>array_like</em> @n
#   Array containing numbers whose minimum is desired. If @em a is not an array, a conversion is attempted.
# @param axis : <em>None or int or tuple of ints, @b optional</em> @n
#   Axis or axes along which to operate. By default, flattened input is used. @n
#   If this is a tuple of ints, the minimum is selected over multiple axes.
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   Alternative output array in which to place the result.
#   Must be of the same shape and buffer length as the expected output.
# @param keepdims : <em>bool, @b optional</em> @n
#   If this is set to True, the axes which are reduced are left in the result as dimensions with size one.
#   With this option, the result will broadcast correctly against the input array.
# @param initial : <em>scalar, @b optional</em> @n
#   The maximum value of an output element. Must be present to allow computation on empty slice.
#   See @ref ufunc.reduce "reduce" for details.
# @param where : <em>array_like of bool, @b optional</em> @n
#   Elements to compare for the minimum. See @ref ufunc.reduce "reduce" for details.
# @retval amin : <em>@ref n-dimensional_array "ndarray"</em> @n
#   An array with the same shape as @em a, with the specified axis removed. If @em a is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as @em a is returned.
# @sa
#   @li @ref amax : Returns the maximum of an array or maximum along an axis.
#   @li @ref nanmin : Returns minimum of an array or minimum along an axis, ignoring %any NaNs.
#   @li @ref ufuncs.minimum "minimum" : Element-wise minimum of array elements.
#   @li @ref ufuncs.fmin "fmin" : Element-wise minimum of array elements.
#   @li @ref searching.argmin "argmin" : Returns the indices of the minimum values along an axis.
#   @li @ref nanmax : Returns the maximum of an array or maximum along an axis, ignoring %any NaNs.
#   @li @ref ufuncs.maximum "maximum" : Element-wise maximum of array elements.
#   @li @ref ufuncs.fmax "fmax" : Element-wise maximum of array elements.
# @note
#   NaN values are propagated, that is if at least one item is NaN, the corresponding min value will be NaN as well. To ignore NaN values, please use nanmin. @n
#   Don't use @ref amin for element-wise comparison of 2 arrays; when <span class="pre">a.shape[0]</span> is 2, <span class="pre">minimum(a[0], a[1])</span> is faster than <span class="pre">amin(a, axis=0)</span>.
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.arange(4).reshape((2,2))
# >>> a
# array([[0, 1],
#        [2, 3]])
# >>> vp.amin(a)           # Minimum of the flattened array
# array(0)
# >>> vp.amin(a, axis=0)   # Minima along the first axis
# array([0, 1])
# >>> vp.amin(a, axis=1)   # Minima along the second axis
# array([0, 2])
# >>> vp.amin(a, where=[False, True], initial=10, axis=0)
# array([10,  1])
# @endcode @n
# @code
# >>> b = vp.arange(5, dtype=float)
# >>> b[2] = vp.NaN
# >>> vp.amin(b)
# array(nan)
# >>> vp.amin(b, where=~vp.isnan(b), initial=10)
# array(0.)
# >>> vp.nanmin(b)
# array(0.)
# @endcode
# @endpydoc
# @endif
def amin(a, axis=None, out=None, keepdims=nlcpy._NoValue,
         initial=nlcpy._NoValue, where=nlcpy._NoValue):
    args = dict()
    if keepdims is not nlcpy._NoValue:
        args["keepdims"] = keepdims
    if initial is not nlcpy._NoValue:
        args["initial"] = initial
    if where is not nlcpy._NoValue:
        args["where"] = where
    return nlcpy.minimum.reduce(a, axis=axis, out=out, **args)


## @fn nanmax(a, axis=None, out=None, keepdims=<no value>)
# @rename order.nanmax nanmax nlcpy.nanmax
# @ingroup Order_statistics
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns maximum of an array or maximum along an axis, ignoring any NaNs.
# @details When all-NaN slices are encountered a <span class="pre">RuntimeWarning</span> is raised and Nan is returned for that slice.
# @param a : <em>array_like</em> @n
#   Array containing numbers whose maximum is desired. If @em a is not an array, a conversion is attempted.
# @param axis : <em>None or int or tuple of ints, @b optional</em> @n
#   Axis or axes along which to operate. By default, flattened input is used. @n
#   If this is a tuple of ints, the maximum is selected over multiple axes.
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   Alternative output array in which to place the result.
#   Must be of the same shape and buffer length as the expected output.
# @param keepdims : <em>bool, @b optional</em> @n
#   If this is set to True, the axes which are reduced are left in the result as dimensions with size one.
#   With this option, the result will broadcast correctly against the input array.
# @retval nanmax : <em>@ref n-dimensional_array "ndarray"</em> @n
#   An array with the same shape as @em a, with the specified axis removed. If @em a is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as @em a is returned.
# @sa
#   @li @ref nanmin : Returns the minimum of an array or minimum along an axis, ignoring %any NaNs.
#   @li @ref amax : Returns the maximum of an array or maximum along an axis.
#   @li @ref ufuncs.fmax "fmax" : Element-wise maximum of array elements.
#   @li @ref ufuncs.maximum "maximum" : Element-wise maximum of array elements.
#   @li @ref ufuncs.isnan "isnan" : Tests element-wise for NaN and return result as a boolean array.
#   @li @ref ufuncs.isfinite "isfinite" : Tests element-wise for finiteness (not infinity or not Not a Number).
#   @li @ref amin : Returns the minimum of an array or maximum along an axis.
#   @li @ref ufuncs.fmin "fmin" : Element-wise minimum of array elements.
#   @li @ref ufuncs.minimum "minimum" : Element-wise minimum of array elements.
# @note
#   NLCPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).
#   This means that Not a Number is not equivalent to infinity.
#   Positive infinity is treated as a very large number and negative infinity is
#   treated as a very small (i.e. negative) number. @n
#   If the input has a integer type the function is equivalent to nlcpy.amax.
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([[1, 2], [3, vp.nan]))
# >>> vp.nanmax(a)
# array(3.)
# >>> vp.nanmax(a, axis=0)
# array([3., 2.])
# >>> vp.nanmax(a, axis=1)
# array([2., 3.])
# @endcode @n
# When positive infinity and negative infinity are present:
# @code
# >>> vp.nanmax([1, 2, vp.nan, vp.inf])
# array(2.)
# >>> vp.nanmax([1, 2, vp.nan, vp.NINF])
# array(inf)
# @endcode
# @endpydoc
# @endif
def nanmax(a, axis=None, out=None, keepdims=nlcpy._NoValue):
    a = nlcpy.core.argument_conversion(a)
    args = dict()
    if keepdims is not nlcpy._NoValue:
        args["keepdims"] = keepdims
    res = nlcpy.fmax.reduce(a, axis=axis, out=out, **args)
    if type(res) is nlcpy.ndarray and nlcpy.any(nlcpy.isnan(res)):
        warnings.warn("All-NaN slice encountered", RuntimeWarning)
    return res


## @fn nanmin(a, axis=None, out=None, keepdims=<no value>)
# @rename order.nanmin nanmin nlcpy.nanmin
# @ingroup Order_statistics
# @if(lang_ja)
# @else
# @pydoc
# @brief Returns minimum of an array or minimum along an axis, ignoring any NaNs.
# @details When all-NaN slices are encountered a <span class="pre">RuntimeWarning</span> is raised and Nan is returned for that slice.
# @param a : <em>array_like</em> @n
#   Array containing numbers whose minimum is desired. If @a a is not an array, a conversion is attempted.
# @param axis : <em>None or int or tuple of ints, @b optional</em> @n
#   Axis or axes along which to operate. By default, flattened input is used. @n
#   If this is a tuple of ints, the minimum is selected over multiple axes.
# @param out : <em>@ref n-dimensional_array "ndarray", @b optional</em> @n
#   Alternative output array in which to place the result.
#   Must be of the same shape and buffer length as the expected output.
# @param keepdims : <em>bool, @b optional</em> @n
#   If this is set to True, the axes which are reduced are left in the result as dimensions with size one.
#   With this option, the result will broadcast correctly against the input array.
# @retval nanmin : <em>@ref n-dimensional_array "ndarray"</em> @n
#   An array with the same shape as @em a, with the specified axis removed. If @em a is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as @em a is returned.
# @sa
#   @li @ref nanmax : Returns the maximum of an array or maximum along an axis, ignoring %any NaNs.
#   @li @ref amin : Returns the minimum of an array or maximum along an axis.
#   @li @ref ufuncs.fmin "fmin" : Element-wise minimum of array elements.
#   @li @ref ufuncs.minimum "minimum" : Element-wise minimum of array elements.
#   @li @ref ufuncs.isnan "isnan" : Tests element-wise for NaN and return result as a boolean array.
#   @li @ref ufuncs.isfinite "isfinite" : Tests element-wise for finiteness (not infinity or not Not a Number).
#   @li @ref amax : Returns the maximum of an array or maximum along an axis.
#   @li @ref ufuncs.fmax "fmax" : Element-wise maximum of array elements.
#   @li @ref ufuncs.maximum "maximum" : Element-wise maximum of array elements.
# @note
#   NLCPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).
#   This means that Not a Number is not equivalent to infinity.
#   Positive infinity is treated as a very large number and negative infinity is
#   treated as a very small (i.e. negative) number. @n
#   If the input has a integer type the function is equivalent to nlcpy.amin.
# @par Example
# @code
# >>> import nlcpy as vp
# >>> a = vp.array([[1, 2], [3, vp.nan]))
# >>> vp.nanmin(a)
# array(1.)
# >>> vp.nanmin(a, axis=0)
# array([1., 2.])
# >>> vp.nanmin(a, axis=1)
# array([1., 3.])
# @endcode @n
# When positive infinity and negative infinity are present:
# @code
# >>> vp.nanmin([1, 2, vp.nan, vp.inf])
# array(1.)
# >>> vp.nanmin([1, 2, vp.nan, vp.NINF])
# array(-inf)
# @endcode
# @endpydoc
# @endif
def nanmin(a, axis=None, out=None, keepdims=nlcpy._NoValue):
    a = nlcpy.core.argument_conversion(a)
    args = dict()
    if keepdims is not nlcpy._NoValue:
        args["keepdims"] = keepdims
    res = nlcpy.fmin.reduce(a, axis=axis, out=out, **args)
    if type(res) is nlcpy.ndarray and nlcpy.any(nlcpy.isnan(res)):
        warnings.warn("All-NaN slice encountered", RuntimeWarning)
    return res
## @}
#
